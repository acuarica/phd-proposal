

\definecolor{header-color}{HTML}{D1D1D1}
\definecolor{alt-row-color}{HTML}{ECECEC}

\newcommand{\hdr}{\rowcolor{header-color}}
\newcommand{\alt}{\rowcolor{alt-row-color}}
\newcommand{\row}{}

\newcommand{\javaclass}[1]{\emph{#1}}
\newcommand{\member}[1]{\emph{#1}}
\newcommand{\smugroup}[1]{\textsl{#1}}
\newcommand{\stackoverflow}{Stack Overflow}

\newcommand\namealloc{Allocate an Object without Invoking a Constructor}
\newcommand\nameprobyte{Process Byte Arrays in Block}
\newcommand\namelockfree{Atomic Operations}
\newcommand\namefence{Strongly Consistent Shared Variables}
\newcommand\namepark{Park/Unpark Threads}
\newcommand\namefinalfield{Update Final Fields}
\newcommand\namemonitor{Non-Lexically-Scoped Monitors}
\newcommand\nameserialization{Serialization/Deserialization}
\newcommand\namemarshalling{Foreign Data Access and Object Marshaling}
\newcommand\namethrow{Throw Checked Exceptions without Being Declared}
\newcommand\namesize{Get the Size of an Object or an Array}
\newcommand\namelargearrays{Large Arrays and Off-Heap Data Structures}
\newcommand\namepage{Get Memory Page Size}
\newcommand\nameclass{Load Class without Security Checks}

\chapter{The \java{} Unsafe \api{} in the Wild}
\label{cha:unsafe}

We already have published our work on how developers use the \code{sun.misc.Unsafe} API.

We have found 14 usage patterns 

We have analyzed $74 GB$ of compiled \lang{Java} code,
spread over $86,479$ \lang{Java} archives, to determine how \lang{Java}'s unsafe capabilities are used in real-world libraries and applications.
We found that $25\%$ of \lang{Java} bytecode archives depend on unsafe third-party \java{} code, and thus \java{}'s safety guarantees cannot be trusted.
We identify $14$ different usage patterns of \java{}'s unsafe capabilities, and we provide supporting evidence for why real-world code needs these capabilities.
Our long-term goal is to provide a foundation for the design of new language features to regain safety in \lang{Java}.

For more details refer to~\cite{mastrangeloUseYourOwn2015}.




\section{Discussion}
\label{sec:unsafe:discussions}

Many of the patterns we found indicate that \unsafe{} is used to achieve 
better performance or to implement functionality not otherwise available in the
Java language or standard library.

However, many of the patterns described can be implemented using APIs
already provided in the Java standard library. 
In addition, there are several existing proposals to improve the situation
with \unsafe{} already under development within the Java community.
Oracle software engineer Paul Sandoz~\cite{psandoz14} performed a survey on
the OpenJDK mailing list to
study how Unsafe is
used\footnote{\url{http://www.infoq.com/news/2014/02/Unsafe-Survey}} and
describes several of these proposals.

\input{table-alts}

A summary of the patterns with existing and proposed alternatives to \unsafe{} is shown in Table~\ref{table:alts}.
The table consists of the following columns:
The \textbf{\em Pattern} column indicates the name of the pattern.
The next three columns indicate whether the pattern could be implemented either as a
language feature (\textbf{\em Lang}),
virtual machine extension (\textbf{\em VM}),
or
library extension (\textbf{\em Lib}).
The \textbf{\em Ref} column indicates that the pattern can be
implemented using reflection.
A bullet (\exis) indicates that an
alternative exists in the Java language or API. A check mark (\tick)
indicates that there is a proposed alternative for Java.


Many Java APIs already exist that provide functionality similar to \unsafe{}.
Indeed, these APIs are often implemented using \unsafe{} under the hood, but 
they are designed to be used safely.
They maintain invariants or perform runtime checks
to ensure that their use of \unsafe{} is safe.
Because of this overhead, using \unsafe{}
directly should in principle provide better performance at the cost of safety.
% We are unaware of any studies measuring this overhead, however.

For example,
the \javaclass{java.\-util.\-concurrent} package provides classes 
for safely performing atomic operations on fields and array elements, as well
as several synchronizer classes. These
classes
can be used instead of \unsafe{} to implement
atomic operations (Section~\ref{sec:lockfree}) or strongly consistent
shared variables (Section~\ref{sec:fence}).
The standard library class
\javaclass{java.\-util.\-concurrent.\-locks.\-LockSupport} provides
\member{park} and \member{unpark}
methods to be used for implementing locks. 
These methods are just thin wrappers
around the \smu{} methods of the same name and 
could be used to implement the park pattern (Section~\ref{sec:park}).
Java already supports serialization of objects
(Section~\ref{sec:serialization}) using the
\javaclass{java.lang.Serializable} and
\javaclass{java.io.Object\-Output\-Stream} API.
The now-deleted JEP 187 Serialization 2.0 proposal\footnote{\url{http://mail.openjdk.java.net/pipermail/core-libs-dev/2014-January/024589.html}}
\footnote{\url{http://web.archive.org/web/20140702193924/http://openjdk.java.net/jeps/187}}
addresses some of the issues with Java serialization.

Because volatile variable accesses compile to code that issues memory fences, 
strongly consistent variables (Section~\ref{sec:fence}) can be implemented by accessing volatile variables.
However, the fences generated for volatile variables may be stronger (and
therefore less performant) than are
needed for a given application. Indeed, the \unsafe{} \smugroup{Put Ordered}
and \smugroup{Fence} methods were likely introduced
to improve performance versus volatile variables. There is currently a proposal
for enhanced volatile support in the JVM
(JEP 193 Enhanced Volatiles~\cite{jep193}).
This proposal introduces \emph{variable handles}, which allow
atomic operations on fields and array elements.

Many of the patterns can be implemented using the reflection API, albeit
with lower performance than with \unsafe{}~\cite{Korl_noninvasiveconcurrency}.
For example,
reflection can be used for accessing object fields to implement serialization
(Section~\ref{sec:serialization}).
Similarly, reflection can be used
in combination with
\javaclass{java.nio.Byte\-Buffer} and related classes for
data marshaling (Section~\ref{sec:marshalling}).
The reflection API can also be used to write to final fields
(Section~\ref{sec:finalfield}).
However, this feature of the reflection API 
makes sense only during deserialization or during object construction and may have
unpredictable behavior in other
cases.

\footnote{\url{http://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Field.html\#set(java.lang.Object,\%20java.lang.Object)}}

Writing a final field through reflection may not ensure
the write becomes visible to other threads that might have cached the final
field, and it may not work correctly at all if the VM performs compiler
optimizations such as constant propagation on final fields.

Many patterns use \unsafe{} to use memory more efficiently.
Using structs or packed objects can reduce memory overhead by eliminating 
object headers and other per-object overhead.
Java has no native support for structs, but
they can be implemented with byte buffers or with
JNI.\footnote{\url{http://www.oracle.com/technetwork/java/jvmls2013sciam-2013525.pdf}}

The Arrays 2.0
proposal~\cite{arrays20} and the value types proposal~\cite{valuetypes}
address the large arrays pattern (Section~\ref{sec:largearrays}). 
Project Sumatra~\cite{layouts} proposes features for accessing GPUs
and other accelerators, one of the use cases for foreign data access
(Section~\ref{sec:marshalling}).
Related proposals include JEP 191~\cite{jep191}, which proposes a
new 
foreign function interface for Java, and Project Panama~\cite{panama},
which supports native data access from the JVM.

A \member{sizeof} feature could be introduced into the language or
into the standard library (Section~\ref{sec:size}).
A use case for this feature includes cache management implementations.
A higher level alternative might be to provide an API for memory usage tracking in the
JVM.
A page size (Section~\ref{sec:page}) method could be added to 
the standard library, perhaps in
  the \javaclass{java.nio} package, which already includes
\javaclass{MappedByteBuffer} to access memory-mapped storage.


Other patterns may require Java language changes. For instance, 
the language could be changed to not require methods to declare 
the exceptions they throw, obviating the need for \unsafe{}
(Section~\ref{sec:throw}) in this case.
  Indeed, there is a long-running
  debate\footnote{\url{http://www.ibm.com/developerworks/library/j-jtp05254/}} about the
  software-engineering benefits of checked exceptions.
C\#, for instance, does not require that exceptions be declared in method signatures at all.
One alternative not requiring a language change, proposed in a \stackoverflow
discussion, is to use Java generics
instead.\footnote{\url{http://stackoverflow.com/questions/11410042}} Because
of type erasure, a checked exception can be coerced unsafely into an unchecked exception and thrown.

Changing the language to support allocation without constructors
(Section~\ref{sec:alloc}) or non-lexically-scoped monitors
(Section~\ref{sec:monitor}) is feasible. However, implemention of these
features must be done carefully to ensure object invariants
are properly maintained. In particular, supporting arbitrary unconstructed
objects can require type system changes to prevent usage of the object 
before initialization~\cite{Qi:2009:MTS:1480881.1480890}. Limiting the scope
of this feature to support deserialization only may be a good compromise and
has been suggested in the JEP 187 Serialization 2.0 proposal.

Since \unsafe{} is often used simply for performance reasons, virtual machine
optimizations can reduce the need for \unsafe{}.
For example, 
the JVM's runtime compiler can be extended with optimizations for vectorizing
byte array accesses, eliminating the motivation to use \unsafe{} to process byte
arrays (Section~\ref{sec:probyte}).
Many patterns use \unsafe{} to use memory more efficiently.
This could be ameliorated with lower GC overhead. There are proposals for
this, for instance JEP 189 Shenandoah: Low Pause GC~\cite{jep189}.







\section{Related Work}
\label{sec:unsafe:relatedwork}

Oracle software engineer Paul Sandoz 
performed some informal analysis of Maven artifacts and usages in Grepcode~\cite{sandoz-personal-communication}
and conducted a survey to study how \unsafe{} is used~\cite{psandoz14}.
The survey consists of 7 questions\footnote{\url{http://www.infoq.com/news/2014/02/Unsafe-Survey}} 
that help to understand what pieces of \smu{} should be mainstreamed.
We go beyond Sandoz' work
by performing a comprehensive study of the \mavencentral{} software repository to analyze how and why \smu{} is being used.

In the remainder of this section we first describe the related work about mining software repositories to understand a specific language feature.
Then, we show where \unsafe{} fits in the broader spectrum, i.e., how to do low-level coding in a high level language.


\subsection{Mining Repositories to Assess Language Features}

Several researchers have mined software repositories with the goal of analyzing and understanding if, how and when certain programming language features are being used.

Dyer et. al.~\cite{Dyer-Rajan-Nguyen-Nguyen-14} studied the adoption of Java language features over time. Richards et. al.~\cite{Richards:2011:EML:2032497.2032503} present an in-depth study on the \texttt{eval} function in JavaScript. Mayer et. al.~\cite{Mayer:2012:ESI:2384616.2384666} studied the impact of type systems on software development. Calla\'{u} et. al.~\cite{Callau:2011:DUD:1985441.1985448} performed an empirical study to assess how much the dynamic and reflective features of Smalltalk are actually used in practice. Holkner and Harland~\cite{Holkner:2009:EDB:1862659.1862665} did a similar study on production-stage open source Python programs. Richards et. al.~\cite{Richards:2010:ADB:1806596.1806598} also did a study on the dynamic behavior but applied to JavaScript programs. Gorla et. al.~\cite{Gorla:2014:CAB:2568225.2568276} mined a large set of Android applications, clustering applications by their description topics and identifying outliers in each cluster with respect to their API usage. Grechanik et. al.~\cite{Grechanik:2010:EIL:1852786.1852801} also mined large scale software repositories to obtain several statistics on how source code is actually written.

\subsection{High-Level Language Semantics for Low-Level Coding}

Oracle provides the \smu{} class for low-level programming, e.g, synchronization primitives, direct memory access methods, array manipulation and memory usage. Although the \smu{} class is not officially documented, there is literature based on it.

Korland et. al.~\cite{Korl_noninvasiveconcurrency} presented a Java STM framework, intended as a development platform for scalable concurrent applications and as a research tool for designing STM algorithms. They chose to use \smu{} to implement fast reflection, as it proved to be vastly more efficient than the standard Java reflection mechanisms. Pukall et. al.~\cite{SPE:SPE2107} introduced a runtime update approach based on Java that offers flexible dynamic software updates with minimal performance overhead. They used the \texttt{allocateInstance} method, because it eases the creation of instances even if the class has no default constructor. Gligoric et. al.~\cite{Gligoric:2011:CFD:2001420.2001456} proposed a new approach to serialization/deserialization via code generation, using \smu{} to allocate instances and to set the fields. The Jikes RVM~\cite{Alpern:2005:JRV:1086608.1086625} is a Java Virtual Machine targeting researchers in runtime systems. It is a Java-in-Java virtual machine because is itself built in Java, a style of implementation termed meta-circular. The Jikes RVM provides an implementation of \smu{} with the \emph{magic} framework. Frampton et. al.~\cite{Frampton:2009:DMH:1508293.1508305} proposed \texttt{org.vmmagic} to provide an escape hatch to low-level alternatives needed to build virtual machines; however, they require compiler support.
