

\definecolor{header-color}{HTML}{D1D1D1}
\definecolor{alt-row-color}{HTML}{ECECEC}

\newcommand{\hdr}{\rowcolor{header-color}}
\newcommand{\alt}{\rowcolor{alt-row-color}}
\newcommand{\row}{}

\newcommand{\javaclass}[1]{\emph{#1}}
\newcommand{\member}[1]{\emph{#1}}
\newcommand{\smugroup}[1]{\textsl{#1}}
\newcommand{\stackoverflow}{Stack Overflow}

\newcommand\namealloc{Allocate an Object without Invoking a Constructor}
\newcommand\nameprobyte{Process Byte Arrays in Block}
\newcommand\namelockfree{Atomic Operations}
\newcommand\namefence{Strongly Consistent Shared Variables}
\newcommand\namepark{Park/Unpark Threads}
\newcommand\namefinalfield{Update Final Fields}
\newcommand\namemonitor{Non-Lexically-Scoped Monitors}
\newcommand\nameserialization{Serialization/Deserialization}
\newcommand\namemarshalling{Foreign Data Access and Object Marshaling}
\newcommand\namethrow{Throw Checked Exceptions without Being Declared}
\newcommand\namesize{Get the Size of an Object or an Array}
\newcommand\namelargearrays{Large Arrays and Off-Heap Data Structures}
\newcommand\namepage{Get Memory Page Size}
\newcommand\nameclass{Load Class without Security Checks}

\chapter{The \java{} Unsafe \api{} in the Wild}
\label{cha:unsafe}

We already have published our work on how developers use the \code{sun.misc.Unsafe} API.

We have found 14 usage patterns 

We have analyzed $74 GB$ of compiled \lang{Java} code,
spread over $86,479$ \lang{Java} archives, to determine how \lang{Java}'s unsafe capabilities are used in real-world libraries and applications.
We found that $25\%$ of \lang{Java} bytecode archives depend on unsafe third-party \java{} code, and thus \java{}'s safety guarantees cannot be trusted.
We identify $14$ different usage patterns of \java{}'s unsafe capabilities, and we provide supporting evidence for why real-world code needs these capabilities.
Our long-term goal is to provide a foundation for the design of new language features to regain safety in \lang{Java}.

For more details refer to~\cite{mastrangeloUseYourOwn2015}.


\section{Discussion}
\label{sec:unsafe:discussions}

Many of the patterns we found indicate that \unsafe{} is used to achieve 
better performance or to implement functionality not otherwise available in the
Java language or standard library.

However, many of the patterns described can be implemented using APIs
already provided in the Java standard library. 
In addition, there are several existing proposals to improve the situation
with \unsafe{} already under development within the Java community.
Oracle software engineer Paul Sandoz~\cite{psandoz14} performed a survey on
the OpenJDK mailing list to
study how Unsafe is
used\footnote{\url{http://www.infoq.com/news/2014/02/Unsafe-Survey}} and
describes several of these proposals.

\input{table-alts}

A summary of the patterns with existing and proposed alternatives to \unsafe{} is shown in Table~\ref{table:alts}.
The table consists of the following columns:
The \textbf{\em Pattern} column indicates the name of the pattern.
The next three columns indicate whether the pattern could be implemented either as a
language feature (\textbf{\em Lang}),
virtual machine extension (\textbf{\em VM}),
or
library extension (\textbf{\em Lib}).
The \textbf{\em Ref} column indicates that the pattern can be
implemented using reflection.
A bullet (\exis) indicates that an
alternative exists in the Java language or API. A check mark (\tick)
indicates that there is a proposed alternative for Java.


Many Java APIs already exist that provide functionality similar to \unsafe{}.
Indeed, these APIs are often implemented using \unsafe{} under the hood, but 
they are designed to be used safely.
They maintain invariants or perform runtime checks
to ensure that their use of \unsafe{} is safe.
Because of this overhead, using \unsafe{}
directly should in principle provide better performance at the cost of safety.
% We are unaware of any studies measuring this overhead, however.

For example,
the \javaclass{java.\-util.\-concurrent} package provides classes 
for safely performing atomic operations on fields and array elements, as well
as several synchronizer classes. These
classes
can be used instead of \unsafe{} to implement
atomic operations or strongly consistent
shared variables.
The standard library class
\javaclass{java.\-util.\-concurrent.\-locks.\-LockSupport} provides
\member{park} and \member{unpark}
methods to be used for implementing locks. 
These methods are just thin wrappers
around the \smu{} methods of the same name and 
could be used to implement the park pattern.
Java already supports serialization of objects using the
\javaclass{java.lang.Serializable} and
\javaclass{java.io.Object\-Output\-Stream} API.
The now-deleted JEP 187 Serialization 2.0 proposal\footnote{\url{http://mail.openjdk.java.net/pipermail/core-libs-dev/2014-January/024589.html}}
\footnote{\url{http://web.archive.org/web/20140702193924/http://openjdk.java.net/jeps/187}}
addresses some of the issues with Java serialization.

Because volatile variable accesses compile to code that issues memory fences, 
strongly consistent variables can be implemented by accessing volatile variables.
However, the fences generated for volatile variables may be stronger (and
therefore less performant) than are
needed for a given application. Indeed, the \unsafe{} \smugroup{Put Ordered}
and \smugroup{Fence} methods were likely introduced
to improve performance versus volatile variables. There is currently a proposal
for enhanced volatile support in the JVM
(JEP 193 Enhanced Volatiles~\cite{jep193}).
This proposal introduces \emph{variable handles}, which allow
atomic operations on fields and array elements.

Many of the patterns can be implemented using the reflection API, albeit
with lower performance than with \unsafe{}~\cite{korlandNoninvasiveConcurrencyJava2010}.
For example,
reflection can be used for accessing object fields to implement serialization.
Similarly, reflection can be used
in combination with
\javaclass{java.nio.Byte\-Buffer} and related classes for
data marshaling.
The reflection API can also be used to write to final fields.
However, this feature of the reflection API 
makes sense only during deserialization or during object construction and may have
unpredictable behavior in other
cases.

% \footnote{\url{http://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Field.html\#set(java.lang.Object,\%20java.lang.Object)}}

Writing a final field through reflection may not ensure
the write becomes visible to other threads that might have cached the final
field, and it may not work correctly at all if the VM performs compiler
optimizations such as constant propagation on final fields.

Many patterns use \unsafe{} to use memory more efficiently.
Using structs or packed objects can reduce memory overhead by eliminating 
object headers and other per-object overhead.
Java has no native support for structs, but
they can be implemented with byte buffers or with
JNI.\footnote{\url{http://www.oracle.com/technetwork/java/jvmls2013sciam-2013525.pdf}}

The Arrays 2.0
proposal~\cite{arrays20} and the value types proposal~\cite{valuetypes}
address the large arrays pattern. 
Project Sumatra~\cite{layouts} proposes features for accessing GPUs
and other accelerators, one of the use cases for foreign data access.
Related proposals include JEP 191~\cite{jep191}, which proposes a
new 
foreign function interface for Java, and Project Panama~\cite{panama},
which supports native data access from the JVM.

A \member{sizeof} feature could be introduced into the language or
into the standard library.
A use case for this feature includes cache management implementations.
A higher level alternative might be to provide an API for memory usage tracking in the
JVM.
A page size method could be added to 
the standard library, perhaps in
  the \javaclass{java.nio} package, which already includes
\javaclass{MappedByteBuffer} to access memory-mapped storage.


Other patterns may require Java language changes.
For instance, 
the language could be changed to not require methods to declare 
the exceptions they throw, obviating the need for \unsafe{} in this case.
  Indeed, there is a long-running
  debate\footnote{\url{http://www.ibm.com/developerworks/library/j-jtp05254/}} about the
  software-engineering benefits of checked exceptions.
C\#, for instance, does not require that exceptions be declared in method signatures at all.
One alternative not requiring a language change, proposed in a \stackoverflow
discussion, is to use Java generics
instead.\footnote{\url{http://stackoverflow.com/questions/11410042}} Because
of type erasure, a checked exception can be coerced unsafely into an unchecked exception and thrown.

Changing the language to support allocation without constructors or non-lexically-scoped monitors is feasible.
However, implementation of these
features must be done carefully to ensure object invariants
are properly maintained. In particular, supporting arbitrary unconstructed
objects can require type system changes to prevent usage of the object 
before initialization~\cite{qiMaskedTypesSound2009}.
Limiting the scope of this feature to support deserialization only may be a good compromise and
has been suggested in the JEP 187 Serialization 2.0 proposal.

Since \unsafe{} is often used simply for performance reasons, virtual machine
optimizations can reduce the need for \unsafe{}.
For example, 
the JVM's runtime compiler can be extended with optimizations for vectorizing
byte array accesses, eliminating the motivation to use \unsafe{} to process byte
arrays.
Many patterns use \unsafe{} to use memory more efficiently.
This could be ameliorated with lower GC overhead.
There are proposals for this, for instance JEP 189 Shenandoah:
Low Pause GC~\cite{jep189}.
