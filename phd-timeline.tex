
\newenvironment{courses}{\begin{enumerate}}{\end{enumerate}}

\newcommand{\course}[4]{\item[\textit{#1}] \textbf{#2}, #3 (#4 \emph{ECTS})}

\newenvironment{tas}{\begin{enumerate}}{\end{enumerate}}

\newcommand{\ta}[6]{
\item[\textit{#1}] \textbf{#2}, Prof. #3 (#4 \emph{ECTS}, #5) \\
{\footnotesize \url{#6}}
}

\chapter{\phd{} Activities}

\label{ch:phd-timeline}

This chapter provides a summary of activities that I carried on so far as a Ph.D. student.
In \cref{sec:ects} and \cref{sec:ta} a list of courses that I have
attended and assisted respectively are shown.
My research activities are introduced in \cref{sec:research}.
Finally, in \cref{sec:service} my academic service is presented.

\section{Attended Courses} \label{sec:ects}

The following is the list of courses that I have attended in order to fulfill the Breadth of Knowledge requirement as stated in Art. 13 under the \emph{\phd{} Program Regulations}\footnote{\url{http://www.inf.usi.ch/phd-regulations-2010-320410.pdf}}.

\begin{courses}
\course{Fall '13}{Ubiquitous Computing}{Prof. Marc Langheinrich}{3}
\course{Fall '13}{Optimistic \& Speculative Dynamic Compilation Techniques}{\emph{Multiple Prof.}}{1}
\course{Spring '14}{Bugs}{Prof. Matthias Hauswirth, Prof. Nate Nystrom}{4}
\course{Spring '14}{Introduction to doctoral studies}{Prof. Antonio Carzaniga}{2}
\course{Spring '15}{Summer School on DSL Design and Implementation}{\emph{Multiple Prof.}}{1}
\course{Spring '17}{Compiler Construction}{Prof. Nate Nystrom}{4}
\end{courses}

Given that the \textbf{total ECTS is 15}, the \emph{Breadth of Knowledge} Requirement is fulfilled.


\section{Teaching Assistance} \label{sec:ta}

As a \phd{} student, it is our duty to serve as teaching assistant according to the needs of the Faculty.
Throughout my \phd{} studies, I have been teaching assistant in the following courses:

\begin{tas}
\ta{Fall '13}{Software Performance}{Matthias Hauswirth}{6}{M.Sc. INF}
	{http://boole.inf.usi.ch/sp-2013/}
\ta{Spring '14}{Programming Fundamentals 2}{Matthias Hauswirth}{6}{B.Sc.}
	{http://boole.inf.usi.ch/pf2-2014/}
\ta{Fall '14}{Programming Fundamentals 3}{Walter Binder}{6}{B.Sc.}
	{https://www2.icorsi.ch/course/view.php?id=3379}
\ta{Spring '15}{Programming Fundamentals 2}{Matthias Hauswirth}{6}{B.Sc.}
	{https://informa.inf.usi.ch/course/ejmuXEJPcDRsbXhSb/syllabus}
\ta{Fall '15}{Programming Fundamentals 1}{Nate Nystrom}{6}{B.Sc.}
	{http://usi-pl.github.io/pf1/fa-2015/}
\ta{Spring '16}{Algorithms and Data Structures}{Antonio Carzaniga}{6}{B.Sc.}
	{http://www.inf.usi.ch/carzaniga/edu/algo/}
\ta{Fall '16}{Computer Networking}{Antonio Carzaniga}{6}{B.Sc.}
	{http://www.inf.usi.ch/carzaniga/edu/ntw/index.html}
\ta{Spring '17}{Languages \& Compilers}{Nate Nystrom}{6}{B.Sc.}
	{http://usi-pl.github.io/lc/sp-2017/}
\end{tas}

\section{Research Activities} \label{sec:research}

\subsection*{Java Native Instrumentation Framework (\jnif{})}

I started my \phd{} exploring the state-of-the-art and limits on \java{} instrumentation.
One recurring problem we found was the impossibility of developing \emph{full-coverage} analysis.
That is, analysis that observe the execution of the whole \java{} class library.

To overcome this problem, we have created \jnif{}\footnote{\url{https://gitlab.com/acuarica/jnif}}, the first Java bytecode rewriting tool entirely written in native code.
\jnif{} can be plugged into an \jvmti{}\footnote{\url{http://docs.oracle.com/javase/7/docs/technotes/guides/jvmti/}} agent to create isolated, full-coverage, in-process dynamic instrumentation tools.
With JNIF, the programmer can decode, analyze, edit, and encode Java class files.
\jnif{} is able to generate stack maps, required by split-time verifiers of moderns \jvm{}s.

The results of this work took shape in an article accepted in an international conference~\cite{mastrangelo_jnif:_2014}.

\subsection*{How actually safe is the Java ecosystem?}

Following our work on \jnif{}, I started to study how unsafe is the Java ecosystem.
Java contains an undocumented\footnote{\url{http://www.oracle.com/technetwork/java/faq-sun-packages-142232.html]}} class, \smu{}, that allows the programmer to circumvent \java{}'s safety guarantees.
We wanted to provide a solid understanding on why and how this undocumented class is used.
To that end, we have analyzed a large code-base of real-world Java applications.

This work led to an accepted article in an international conference~\cite{mastrangelo_use_2015}.
We hope that this paper could serve as an starting point to provide a foundation for the design of new languages features to regain safety in Java.

\subsection*{Supercompilation}

After having worked with \java{}, I decided to switch topic completely, to Supercompilation for \haskell{}.
Before switching back to our empirical studies,
we have planed to carry-on our research based on our Supercompiler.
We have implemented a minimal Supercompiler for a functional language\footnote{\url{https://gitlab.com/acuarica/hsc}}, similar to GHC Core, with unrestricted recursive lets.

The reason why we have built our own Supercompiler instead of working with a previous built one like, e.g., Supero\footnote{\url{https://github.com/ndmitchell/supero}}~\cite{mitchell_supercompiler_2007,mitchell_rethinking_2010}, or CHSC\footnote{\url{https://github.com/batterseapower/chsc}}~\cite{bolingbroke_supercompilation_2010} is two-fold.
First, by building our supercompiler we faced in first-hand the real problems the Supercompilation suffer. This was a key point to our goal of improving supercompilation.
Second, it is much easier to modify and extend our own Supercompiler instead of working with a third-party one.

Nevertheless, we have investigated both Supercompilers. In particular, we have tried to incorporate CHSC as a plugin in a recent version of GHC\footnote{\url{https://gitlab.com/acuarica/chsc-plugin}}.

Another direction that we have tried is to understand how rewrite tules compare to Supercompilation\footnote{\url{https://downloads.haskell.org/~ghc/8.2.1/docs/html/users_guide/glasgow_exts.html\#rewrite-rules}}.
Our plan was to understand to what extent manually-written rules can be automatically deduced by Supercompilation.
We have published our partial infrastructure online\footnote{\url{https://gitlab.com/acuarica/rewrite-rules}}$^{,}$\footnote{\url{https://gitlab.com/acuarica/hsc-rules-analysis}}.

All this work led to an article by the Research Co-Advisor in an international symposium~\cite{nystrom_scala_2017}.

\subsection*{Maven Repository Analysis Framework}

Our study with \smu{} had involed analyzing the Maven Repository.
We have extended this analysis to create a database containing every bytecode in the Maven Repository\footnote{\url{https://gitlab.com/acuarica/mavends}}.

To create the bytecode database, we have used our tool \jnif{}.
The original version used ASM, but this suffer performance issues, due to memory leaks. 

Although we do not have any publication with this tool, we hope this artifact can be beneficial to anyone querying bytecode usage.

\section{Service Activities} \label{sec:service}

I have served on the following programme committee.

\subsection*{Artifact Evaluation for OOPSLA '16}

I was selected --- under the recommendation of my Advisor --- to be a reviewer of the Artifact Evaluation Committee for OOPSLA '16.
As an Artifact Evaluation reviewer, my task was to review three companion artifacts selected for evaluation.
I had to understand the selected papers, so then I could evaluate the attached artifact.

The three artifacts I was appointed to --- \cite{ancona_semantic_2016,dilorenzo_incremental_2016,stefanescu_semantics-based_2016} --- were finally accepted.
