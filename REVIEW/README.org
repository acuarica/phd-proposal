
# face/faith? based casting
# Faith vs. evidence: How to know a cast won't fail?

* TODO TODOs                                                       :noexport:
:LOGBOOK:
- State "DONE"       from              [2018-03-02 Fri 15:20]
:END:
** TODO Would TAPL's Benjamin Pierce agree with this introduction?
*** Would he agree with every statement you make here?
*** Would he agree that you use the terminology 100% accurately?
*** If not, improve the writing
** TODO Sounds like a great argument/motivation for your work
*** But: will you really provide answers/help/support in this language design dilemma?
*** If yes, what exactly will you provide that helps here?
** TODO RQs come out from nowhere
*** Add bridge paragraph before
*** Motivate RQs from the points presented right before
** TODO The logical flow of the introduction needs work
There is not a good segue from the opening paragraph on static vs. dynamic languages to the second paragraph on casts.
The second paragraph tries to relate casting and subtyping,
but this has little to do with the static/dynamic discussion, and indeed the though it dropped in the third paragraph.
** DONE There is no "Java Specification"
CLOSED: [2018-03-02 Fri 15:24]
:LOGBOOK:
- State "DONE"       from "DRAFT"      [2018-03-02 Fri 15:24]
- State "DRAFT"      from "TODO"       [2018-03-02 Fri 15:24] \\
  There is indeed a "Java Specification" as pointed out in the link.
:END:
*** Be precise with your words (not just here)
** DONE Enumerate these kinds here
CLOSED: [2018-03-09 Fri 14:25]
:LOGBOOK:
- State "DONE"       from "DRAFT"      [2018-03-09 Fri 14:25]
- State "DRAFT"      from "TODO"       [2018-03-09 Fri 14:25] \\
  Enumerating conversions from the spec
:END:
*** So it becomes explicit what you ignore
** TODO Upcast comes out of nowhere, bad writing
*** Start by partitioning the cases:
*** There are downcast and upcast
*** They mean ~...~
*** Upcast are unnecessary, so we ignore them?
*** Downcast are interesting, so we study them here
** DONE The introduction to casts in Section 2 should talk about the different types of casts in Java
CLOSED: [2018-03-09 Fri 15:14]
:LOGBOOK:
- State "DONE"       from "DRAFT"      [2018-03-09 Fri 15:14]
- State "DRAFT"      from "TODO"       [2018-03-09 Fri 15:14] \\
  Added description in section Casts
:END:
Conversions between primitives (which we don't consider in this paper), downcasts, and upcasts (which are implicit).
Maybe this should be merged into Section 1.
** DONE Needs short but complete info about how you found these
CLOSED: [2018-03-02 Fri 18:37]
:LOGBOOK:
- State "DONE"       from "DRAFT"      [2018-03-02 Fri 18:37]
- State "DRAFT"      from "TODO"       [2018-03-02 Fri 18:37] \\
  Added section finding cast patterns
:END:
** TODO Add 'variations of this pattern'
*** or 'parameters of this pattern'
*** or 'subtypes of this pattern'
** DONE Cite that rule
CLOSED: [2018-03-02 Fri 16:14]
:LOGBOOK:
- State "DONE"       from "DRAFT"      [2018-03-02 Fri 16:14]
- State "DRAFT"      from "TODO"       [2018-03-02 Fri 16:13] \\
  Rule cited https://lgtm.com/rules/910065/
:END:
** TODO Explain this QL code in the text
*** I don't fully understand it
** TODO Add "usage context"
** TODO What is "the source of the cast"?
*** A type?
*** An object?
*** A program point?
*** ~...~?
** TODO Good start, but explain the query more fully
** TODO Why does it matter that the lookup method is non-static?
*** Why does it matter that the lookup key is a String?
*** Why does it matter that the return type is Object?
*** Why do you check both: The formal and actual argument types?
*** What if the argument wasn't a field access, but a literal?
*** Why double check here, too?
** DONE Why is this done?
CLOSED: [2018-03-03 Sat 20:59]
:LOGBOOK:
- State "DONE"       from "DRAFT"      [2018-03-03 Sat 20:59]
- State "DRAFT"      from "TODO"       [2018-03-03 Sat 20:58] \\
  Added explanation and definitions of examples.
:END:
*** Because ~onSuccess(..., ..., ...)~ is overloaded??
*** /i.e./, there are two ~onSuccess~ methods that differ in their argument type?
** DONE Nice, but please, double check that there is /NO/ proposal for introducing something like that
CLOSED: [2018-03-25 Sun 21:19]
:LOGBOOK:
- State "DONE"       from "TODO"       [2018-03-25 Sun 21:19]
:END:
*** And that Java 9 doesn't already have it
** DONE Isn't this query WAAAY too general??
CLOSED: [2018-03-06 Tue 17:35]
:LOGBOOK:
- State "DONE"       from "DRAFT"      [2018-03-06 Tue 17:35]
- State "DRAFT"      from "TODO"       [2018-03-06 Tue 17:35] \\
  Made the query more specific
:END:
*** It fits ANY cast inside an ~equals~ method.
*** This is NOT what the above text promises
*** No connection to an ~instanceof~
*** No comparison to target type
*** IMO, it should be more selective ~...~
** DONE Also WAY too general, fix
CLOSED: [2018-03-07 Wed 14:56]
:LOGBOOK:
- State "DONE"       from "TODO"       [2018-03-07 Wed 14:56]
:END:
** TODO I would begin Section 2 or 3 with some sort of taxonomy of patterns
Guarded vs. unguarded vs. semi-guarded,
the relationship between different patterns (equals is a specialization of typecase for instance).

** TODO The typecase pattern snippet should really have more than one case
** TODO If equals specializes typecase, can it be replaced by a visitor? How would that work?
** TODO Regarding equals
There was some work by Vaziri and Dolby around 2007 on Relation types which addressed the equals problem.
There's also a design pattern used in Scala for writing equals correctly.
There should also be some papers on the issues surrounding ~equals~ and ~hashCode~.

** DONE The names of the patterns should maybe be typeset differently
CLOSED: [2018-03-07 Wed 14:57]
:LOGBOOK:
- State "DONE"       from "DRAFT"      [2018-03-07 Wed 14:57]
- State "DRAFT"      from "TODO"       [2018-03-07 Wed 14:57] \\
  Added a LaTeX macro to do the typesetting.
:END:
*** In bold or italics
** DONE The sources of the snippets should be cited
CLOSED: [2018-03-07 Wed 14:58]
:LOGBOOK:
- State "DONE"       from "TODO"       [2018-03-07 Wed 14:58]
:END:
** TODO Look at all ways to implement ~equals~ method
*** w/ ~instanceof~
*** w/ ~getClass~
*** Describe relationships between patterns/subpatterns
** TODO Main argument of the paper
*** Static/dynamic as side argument for controlled experiments
*** Limits/deficiencies of static typing
*** Shedding light to static type systems, escape hatch
** TODO Downcast vs. Upcast
*** Relate both
*** Find the upcast and then the upcast
*** Evidence that the cast won't fail
** TODO Guarded cast but tests always returns ~false~
** TODO Lookup by ID pattern/Graphic design for Widgets (Android code)
*** XML (DSLs) generated by IDE, enforce an upcast, downcast mandatory
*** Comparison with ~C#~ to write desktop apps
*** Also check JDBC
*** Also javaparser library /e.g./ as ~asArrayAccessExpr~
*** https://github.com/javaparser/javaparser/blob/master/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ArrayAccessExpr.java
** TODO Upcast to Downcast Connection
*** https://docs.google.com/document/d/1N0i4YnHYZESaiz11er7KFwVXMWfdMglZkl2KvmL8LHA/edit?ts=5a9d45b1
** DONE C# has Pattern Matching
CLOSED: [2018-03-21 Wed 17:03]
:LOGBOOK:
- State "DONE"       from "TODO"       [2018-03-21 Wed 17:03]
:END:
** TODO Maybe tight up the Casts section
** TODO Lookup if the cast expression changed since the corresponding ~instanceof~ guard
*** Guess it shouldn't happen
*** Potentially fail
*** Local variables are ok
*** Final path accesses are ok unless is there unsafe or in a constructor
*** In QL there is a DataFlow API
** TODO What is the corpus?
** TODO What is a pattern?
** DONE Java Proposals
CLOSED: [2018-03-21 Wed 15:47]
:LOGBOOK:
- State "DONE"       from "DRAFT"      [2018-03-21 Wed 15:47]
- State "DRAFT"      from "TODO"       [2018-03-15 Thu 10:16] \\
  Added Java proposals
:END:
*** Pattern Matching [fn::http://openjdk.java.net/jeps/305]
*** Data Classes for Java [fn::http://cr.openjdk.java.net/~briangoetz/amber/datum.html]
*** Augment Use-Site Variance with Declaration-Site Defaults [fn::http://openjdk.java.net/jeps/300]
** TODO Typecase should have more than one case
** DONE Approximate seal-ness
CLOSED: [2018-03-20 Tue 16:37]
:LOGBOOK:
- State "DONE"       from "TODO"       [2018-03-20 Tue 16:37]
:END:
** TODO Find good motivation
*** How much does cast are an actual problem?
*** Show that casts are an actual problem for developers
** DONE Simple introduction to QL in group meeting
CLOSED: [2018-03-26 Mon 16:40]
:LOGBOOK:
- State "DONE"       from "TODO"       [2018-03-26 Mon 16:40]
:END:
** DONE Pitch for Semmle people
CLOSED: [2018-03-26 Mon 18:34]
:LOGBOOK:
- State "DONE"       from "DRAFT"      [2018-03-26 Mon 18:34]
- State "DRAFT"      from "TODO"       [2018-03-26 Mon 18:34] \\
  Preparing draft mail
:END:
*** Nate talk to Max in ECOOP PC meeting
*** Mail draft the project to send to Max

In programming languages with subtyping, casts provide the means to bypass the type system.
Avoiding the type system, casts can pose potential threats, because it is like the developer saying to the compiler: "Trust me here, I know what I'm doing".
Therefore, it is important to understand how and why developers use casts and related operators.
We believe having this knowledge can be useful for --- current & future -- language designers (not only Java),
can be a reference for tool builders,
and can be a guide for developers for best (or better) practices.

We are currently working on a paper to study how cast-related operations are being used in Java.
For our study, we are doing an empirical study on Java projects.
We plan to implement it using QL & lgtm, since it is quite powerful and efficient.
However, there are some issues that limit us to perform a full study using your platform.
We were wondering if you would be interested to collaborate with us.
In particular, the issues that we found are:

- Aggregate by project.
The web-interface shows results segmented by project.
Our study requires to gather stats across all projects, e.g., count how many casts instances there are.
Would be possible to have such stats?

- Manipulate result sets.
We already wrote several queries to detect different usages of casts.
Different queries may return the same cast instance.
We would need to manipulate the result set of each query to check where there is a inclusion-relationship between them.

- Representative project-base.
For our preliminary analysis, we start following around 200 projects on GitHub (the most starred ones).
We believe we need a bigger and more representative project base to draw any valid conclusion.
There are around 50k open source projects already analyzed by your platform.
Would be possible to perform our study in your current project base?



Casting is an orthogonal feature of a language that allows a developer to bypass the type system.

Might impose a problem,
What are related problem?
Why do we care?

* DRAFT Study Overview
:LOGBOOK:
- State "DRAFT"      from              [2018-01-19 Fri 13:46] \\
  Imported
:END:
<<sec:studyoverview>>

We believe we should care about how the casting operations are used in the wild if we want to properly support empirical studies related to static type systems.
Therefore, we want to answer the following questions: 
 
- $Q1:$ :: *Are casting operations used in common application code?* 
We want to understand to what extent third-party code actually uses casting operations. 
 
- $Q2:$ :: *Which features of  are used?* 
As provides many features, we want to understand which ones are actually used, and which ones can be ignored. 
 
- $Q3:$ :: *Why are features used?* 
We want to investigate what functionality third-party libraries require from. 
This could point out ways in which the \java{} language and/or the \jvm{} need to be evolved to provide the same functionality, but in a safer way.   
 
To answer the above questions, we need to determine whether and how casting operations are actually used in real-world third-party \java{} libraries. 
To achieve our goal, several elements are needed. 
 
*Code Repository.* 
As a code base representative of the ``real world'', we have chosen the \mavencentral [fn::http://central.sonatype.org/] software repository. 
The rationale behind this decision is that a large number of well-known \java{} projects deploy to \mavencentral{} using Apache Maven[fn::http://maven.apache.org/]. 
Besides code written in \java{}, projects written in \scala{} are also deployed to \mavencentral{} using the Scala Build Tool (sbt)[fn::http://www.scala-sbt.org/]. 
Moreover, \mavencentral{} is the largest \java{} repository[fn::http://www.modulecounts.com/], and it contains projects from the most popular source code management repositories, like \github [fn::https://github.com/] and \sourceforge [fn::http://sourceforge.net/]. 
 
*Artifacts.* 
In Maven terminology, an artifact is the output of the build procedure of a project. 
An artifact can be any type of file, ranging from a \ext{pdf} to a \ext{zip} file. 
However, artifacts are usually \ext{jar} files, which archive compiled \java{} bytecode stored in \ext{class} files. 
 
*Bytecode Analysis.* 
We examine these kinds of artifacts to analyze how they use casting operations. 
We use a bytecode analysis library to search for method call sites and field accesses of the \smu{} class. 
 
*Usage Pattern Detection.* 
After all call sites and field accesses are found, we analyze this information to discover usage patterns. 
It is common that an artifact exhibits more than one pattern. 
Our list of patterns is not exhaustive.  
We have manually investigated the source code of the 100 highest-impact artifacts using \smu{} to understand why and how they are using it. 

* DRAFT Are they casts operator used?
:LOGBOOK:
- State "DRAFT"      from "TODO"       [2018-01-19 Fri 13:48] \\
  Imported
:END:
<<sec:stats>>

Statistics under the Maven repository. 
These stats were collected using the Maven Bytecode Dataset. 
 
| Description                         | Value         | 
|-------------------------------------+---------------| 
| `.jar`s size                        | 88GB          | 
| Number of `.jar`                    | 134,156       | 
| Number of `.jar` w/ classes         | 114,495       | 
| Number of classes                   | 24,109,857    | 
| Number of methods                   | 222,492,323   | 
| Number of bytecode instructions     | 4,421,391,470 | 
| Number of `checkcast` instructions  | 47,622,853    | 
| Number of `instanceof` instructions | 8,411,639     | 
| Number of methods w/ `checkcast`    | 27,019,431    | 
| Number of methods w/ `instanceof`   | 5,267,707     | 
 
Notice that around a 12% of methods contain a `checkcast` instruction. 
Which means that it is used a lot. 
 
But there are way less `instanceof` instructions than `checkcast`. 
What does it mean? 
A lot of `checkcast`s are unguarded. 
 
#+BEGIN_EXAMPLE 
--- Size --- 
Total uncompressed size: 176,925 MB 
--- Structural --- 
Number of classes: 24,116,635 
Number of methods: 222,525,678 
Number of call sites: 661,713,609 
Number of field uses: 334,462,791 
Number of constants: 133,020,244 
--- Instructions --- 
Number of zeroOpCount: 833,070,650 
Number of iincCount: 12,052,811 
Number of multiANewArrayCount: 70,688 
Number of intOpCount: 98,592,545 
Number of jumpCount: 223,854,453 
Number of varCount: 1,227,756,300 
Number of invokeDynamicCount: 1,481,910 
Number of lookupSwitchCount: 1,044,018 
Number of tableSwitchCount: 1,377,260 
--- Casts --- 
Number of CHECKCAST: 47,947,250 
Number of INSTANCEOF: 8,505,668 
Number of ClassCastException: 114,049 
Methods w/ CHECKCAST: 27,033,672 
Methods w/ INSTANCEOF: 5,270,791 
--- Error --- 
Files not found: 150 
#+END_EXAMPLE 
 
So, yes, cast are used.

* IN-THE-PAPER Finding Casts Usage Patterns
:LOGBOOK:
- State "IN-THE-PAPER" from "TODO"       [2018-03-02 Fri 16:41]
- State "TODO"       from "DRAFT"      [2018-03-02 Fri 16:40]
- State "DRAFT"      from              [2018-01-19 Fri 13:46] \\
  Import
:END:
<<sec:methodology>>

We have used the \ql{} cite:avgustinov_ql:_2016 query language within the \lgtm [fn::https://lgtm.com] platform to look for casts instances.
The \ql{} query in listing [[lst:allcasts]] shows how to retrieve all casts expressions.

#+NAME: lst:allcasts
#+CAPTION: \ql{} query to retrieve all cast expressions.
#+ATTR_LATEX: :options style=ql
#+BEGIN_SRC ql
import java

from CastExpr ce
select ce
#+END_SRC

We have used this initial results as a starting point for our analysis.
Afterwards, we have selected a random sample for further inspection.
We manually inspected the mentioned casts trying to understand why and how they were used.
By looking at several casts instances, we start to categorize them in usage patterns.
We have formalize the structure of each pattern using \ql.
These patterns are presented in the following section.

** All Expressions                                                :noexport:
#+NAME: lst:all
#+CAPTION: Fetching /all/ expressions.
#+ATTR_LATEX: :options style=ql
#+BEGIN_SRC ql :results output code :wrap "SRC qlres"
import java

from Expr e
select e
#+END_SRC

To put it in perspective, we also count how many ~Expr~ are in the project.
Using project sample =neo4j/neo4j= [fn::https://lgtm.com/projects/g/neo4j/neo4j/].

The above query returns $24,348$ expression nodes.
But to count only how many cast expression, we have:

which returns $5,264$ results.
This a sign that casting is used quite often in this project.

** Patterns Table :noexport:

#+BEGIN: columnview :skip-empty-rows t :maxlevel 2 :hlines 1 :id local
#+CAPTION: Patterns Discovered using Manual Inspection
| Pattern                                 | Count | Relations              |             Casts | ~instanceof~ s | getClass |
|-----------------------------------------+-------+------------------------+-------------------+----------------+----------|
| Pattern Discovery Using \ql{}           |  5264 |                        |                   |                |          |
| Lookup by ID / Heterogeneous Collection |     3 | unguarded              |               135 |                |          |
| Family Polymorphism                     |       |                        | 56 (25 potential) |                |          |
| Typecase                                |    11 |                        |                65 |             55 |          |
| Factory Method                          |       | redundant              | 26 (24 redundant) |                |          |
| Equals                                  |   254 | typecase, guarded      |                18 |              6 |       12 |
| Search or filter by type                |   693 |                        |                11 |              9 |          |
| Composite container object              |       |                        |                16 |                |          |
| Testing                                 |   840 |                        |                 3 |             13 |          |
| Null                                    |    37 |                        |                11 |                |          |
| Query Result                            |       |                        |                11 |                |          |
| Payload                                 |       | typecase               |                10 |                |          |
| Lookup by type tag                      |    15 | typecase               |                 9 |                |          |
| Argument check                          |   207 | equals                 |                 3 |              6 |          |
| Reflection field or invoke              |    12 |                        |                 7 |              1 |          |
| Stash                                   |   193 |                        |                 8 |                |          |
| Object in collection                    |    65 |                        |                 8 |                |          |
| Covariant field of supertype            |       |                        |                 8 |                |          |
| Return Type Test/instanceof             |    20 |                        |                 3 |              5 |          |
| Type parameter                          |       |                        |                 7 |                |          |
| newInstance                             |    23 |                        |                 5 |              1 |          |
| Redundant cast                          |     0 |                        |                 6 |                |          |
| Add type parameters                     |     0 |                        |                 6 |                |          |
| Remove type parameter                   |   203 |                        |                 5 |                |          |
| readObject                              |     3 |                        |                 4 |                |          |
| Exception for rethrow                   |    40 | typecase               |                 2 |              2 |          |
| Covariant return                        |     8 | equals, family, clone  |                 3 |                |          |
| Result check                            |     - |                        |                 1 |              2 |          |
| Clone                                   |     2 |                        |                 2 |                |          |
| Throwable.getCause                      |     1 |                        |                 2 |                |          |
| Library method returning Object         |       |                        |                 2 |                |          |
| Method argument of type Object          |   132 | equals, Argument check |                 1 |                |          |
| URL.openConnection                      |     0 |                        |                 1 |                |          |
| Result of binary operation              |     - |                        |                 1 |                |          |
| Type parameter resolution               |    26 |                        |                 1 |                |          |
| Global flag                             |     - | typecase               |                 1 |                |          |
#+END:               

** Mails :noexport:

--- Mathias
One more thing: anything about Scala-specific cast patterns? 
You clearly need to add counts, examples, explanations, reasons, consequences (in terms of the above questions). 
Also, the patterns you have so far are (probably) straightforward to detect (instruction sits in method X, or operates on type Y). 
I'd say you'll need to look deeper (with some program analysis) to find more interesting patterns that consist of multiple instructions. 

--- Nate
I started by downloading github projects. 
I grabbed all Java projects with more than 10,000 stars. 
This was 35 projects. 
They range in size from 992 lines of code to 588,302. 
I don't think this approach is necessarily representative since most of these projects seem to be libraries or frameworks (hence many stars), but I had to start somewhere. 
 
I then searched for casts and instanceofs in the projects. 
I ignored primitive casts. 
I found 33788 casts, 14828 instanceof. 
Nb. we should also look at calls to getClass since these are sometimes used instead of instanceof (particularly often in equals()). 
 
I then started to go through the source by hand, inspecting each cast. 
For each cast (instanceof), I put a comment trying to classify the cast into some sort of pattern. 
Most are easily classifiable, others require inspecting other code to see the type hierarchy. 
I then looked at all the commented casts again and tried to lump them together into more general patterns. 
I only managed to inspect 12 of the smaller projects (including one with 0 casts, one with just 1, and one with just 2). 
The largest project I looked at had 149 casts. 
The remaining projects have from 115 to 11,617 casts (spring-framework). 
My approach clearly doesn't scale, but I wanted to see what I could do manually. 
All in all, I looked at 481 casts and 106 instanceofs. 
 
First thing to note in general. 
Most casts don't have an associated instanceof. 
This is because of, shall we say, a lack of defensive programming. 
I found this surprising. 
It seems a lot of code (particularly Android GUI code) is constructed on top of frameworks that return interface types (or even Object) a lot and cast to application-specific types without checking, because presumably, the programmer knows best. 
 
Here are the patterns I found, in order of usages. 
The family polymorphism pattern is the most dubious, since it requires looking at the class hierarchy in more detail than I did). 
I think some of these patterns could be restated, cleaned up, merged, split, etc. 
 
--- 
 
Now, what to make of this? 
First, I'm not claiming these are all the patterns or that these patterns are the right patterns. 
But, I think we should ask ourselves if doing a static analysis (either on bytecode or source) will find most of these patterns, and if so what kind of analysis is needed. 
Bytecode analysis won't find, say, the redundant cast pattern or some of the patterns involving generics, because these compile into a no-op. 
I think some of these patterns require application-specific knowledge that any static analysis would have difficulty finding. 
 
Most of the patterns are very local: 
you just have to look at the line of code containing the cast or a few lines before it to identify the pattern. 
The main thing is to know where the value being cast is coming from. 
Most of the time, you don't even have to look at the class hierarchy, but for some patterns (e.g., family polymorphism), you do have to know what is the static type of the object being cast and what is its relationship to the cast type? 
For some of the patterns (e.g., stash), it might be useful to find matching calls: 
for instance, one method calls setTag and another calls getTag, casting to the type of the object that set stored by setTag. 
 
Several projects use application-specific type tags rather instanceof. 
Sometimes, type tests are buried in other methods (e.g., the code calls a method that does an instanceof and returns boolean (see the type test pattern), then uses the boolean result to check that a cast will succeed. 
 
I don't have a good sense yet for how many of these patterns are the result of language deficiencies. 
Certainly typecase can be replaced with a visitor pattern (or pattern matching in a better language). 
The family polymorphism pattern requires either type parameters or (better) abstract types. 
Scala was designed to address this. 
lookup by ID requires some sort of typed heterogeneous collections (like an HList), which is difficult even in Scala or Haskell. 
 
--- 
 
Since manual inspection is very slow, I think we need a way to speed up the inspection process. 
I looked at only about 150 casts per hour. 
For the projects I downloaded, at this rate, it would take about 320 hours to look at them all, i.e., 40 hours a week for 8 weeks. 
Clearly we need to be faster, either by sampling or by scaling up the inspection process (crowd sourcing?). 
 
We should be more careful about the choice of projects to inspect. 
Popularity (github stars) isn't exactly representative. 
It was just easy to do the search. 
 
Here are some more questions I had while looking at this: 
- Are casts local? In a given project, are casts limited to just a few classes or are they widespread? 
- How many casts are dominated by an instanceof in the same method (or in another method)? 
- How many typecase are "real" in that there's actually more than one alternative? 
- How often does it happen that an unguarded cast cannot possibly fail in any execution (for instance when there's really only one class implementing an interface and therefore a cast (to the class) must succeed because there are no objects of any other class).
  I'm not sure if this is the right why to ask the question.

** Bytecode stats from SQL DB :noexport:
*** Target Class for `checkcast` 
 
The `checkcast` instruction takes one argument, the class to be casted to. 
The following table shows which are the most used classes that are being casted to. 
Same as target class for `checkcast`. 
Notice the rank of `java.lang.Number`, and how it is not present in `checkcast`. 

*** Sources Values for `checkcast` 
 
The `checkcast` instruction, besides the formal argument, 
takes the object reference on the top of the stack to be casted. 
 
The following table describes which are the most used source 
values for `checkcast`. 
 
The methodology to retrieve this value is to look at the instruction 
previous to `checkcast`. 
This might not be 100% accurate, but it provides a very good approximation. 
 
*The argument for `invokeinterface` is incomplete* 
 
 
Notice the use of `aconst_null` as a source value for `checkcast`. 
Why would you cast on `null`? 
 
*** Source Values for `instanceof` 
 
Same as Source Values for `checkcast`.
 
*** Methodology
**** First approach: Java/ASM 
 
To be able to do this kind of analysis, 
we have dumped every bytecode in every `.jar` file in a SQLite database. 
The size of the database currently is *157GB*. 
 
The first approach was to use **ASM** for Java. 
This approach did not work properly. 
It seems that there is a memory leak either with the SQLite API 
for Java or in **ASM**, because after have analyzed around 7,000 `.jar` files, 
it throws a `OutOfMemoryError`. 
 
**** Second Approach: C++/JNIF 
 
We finally have used the bytecode rewrite library **JNIF** 
to extract every bytecode into a database. 
 
The database is built in another repo, *mavends*. 
 
[MavenDS](https://bitbucket.org/acuarica/mavends) 
 
[JNIF](https://bitbucket.org/acuarica/jnif) 
 
**** Queries 
 
To retrieve the stats showed above, 
we have used SQL queries against the bytecode database. 
Each individual query is aimed to answer a precise question. 
The following list presents all the SQL queries used to retrieve the stats, 
and its respective answer (after the `;`). 
 
- [How many checkcast instructions?](sql/checkcast-count.out) 
- [`checkcast` most used arguments](sql/checkcast-most-used-args.out) 
- [`checkcast` most used targets](sql/checkcast-most-used-target.out) 
- [How many classes?](sql/class-count.out) 
- [How many bytecode instructions?](sql/code-count.out) 
- [How many `equals` methods?](sql/equals-method-count.out) 
- [How many `equals` methods with `checkcast`?](sql/equals-method-w-checkcast-count.out) 
- [How many `equals` methods with `instanceof`?](sql/equals-method-w-instanceof-count.out) 
- [How many `instanceof` instructions?](sql/instanceof-count.out) 
- [`instanceof` most used arguments](sql/instanceof-most-used-args.out) 
- [`instanceof` most used targets](sql/instanceof-most-used-target.out) 
- [How many `.jar` files?](sql/jar-count.out) 
- [How many `.jar` files with classes?](sql/jar-w-classes-count.out) 
- [How many methods?](sql/method-count.out) 
- [How many methods with `checkcast` instruction?](sql/method-w-checkcast-count.out) 
- [How many methods with `instanceof` instruction?](sql/method-w-instanceof-count.out) 
- [How many methods with signature?](sql/methods-w-signature.out) 
 
** Complex Analysis :noexport:
 
Now the following problem comes: How to extract code patterns? 
The database itself is not enough, and it faces scalability problems.
 
**The idea would be to use method slicing, both backward and forward. 
In this way we can see how the casting are being used.**
 
After the slicing, we could implement some sort of method equivalence to detect 
different patterns.
 
** Preliminary Considerations for Bytecode :noexport:
 
For the bytecode analysis, we need to take into consideration certain code is being compiled.
This is why we need to take the following preliminary considerations.
 
*** Simple cast 
 
#+BEGIN_SRC java 
Object o = "Ciao"; 
return (String)o; 
#+END_SRC 
 
#+BEGIN_EXAMPLE 
0: ldc           #2                  // String Ciao 
2: astore_0 
3: aload_0 
4: checkcast     #3                  // class java/lang/String 
7: areturn 
#+END_EXAMPLE 
 
*** Generics vs. Non-generics 
 
The following two Java snippets get compiled to the same bytecode instructions as showed below. 
Notice that the two snippets only differ in the use of Generics. 
 
#+BEGIN_SRC java 
ArrayList l = new ArrayList(); 
l.add("Ciao"); 
return (String)l.get(0); 
#+END_SRC 
 
#+BEGIN_SRC java 
ArrayList<String> l = new ArrayList<String>(); 
l.add("Ciao"); 
return l.get(0); 
#+END_SRC 
 
#+BEGIN_EXAMPLE 
 0: new           #2        // class java/util/ArrayList 
 3: dup 
 4: invokespecial #3        // Method java/util/ArrayList."<init>":()V 
 7: astore_0 
 8: aload_0 
 9: ldc           #4        // String Ciao 
11: invokevirtual #5        // Method java/util/ArrayList.add:(Ljava/lang/Object;)Z 
14: pop 
15: aload_0 
16: iconst_0 
17: invokevirtual #6        // Method java/util/ArrayList.get:(I)Ljava/lang/Object; 
20: checkcast     #7        // class java/lang/String 
23: areturn 
#+END_EXAMPLE 
 
*** Upcast 
 
The following snippet shows how even in the presence of a cast in the source code, 
no actual `checkcast` is emitted. 
 
#+BEGIN_SRC java 
return (Object)"Foo"; 
#+END_SRC 
 
#+BEGIN_EXAMPLE 
0: ldc           #2                  // String Ciao 
2: areturn 
#+END_EXAMPLE 
 
*** Conditional Operator 
 
Using the conditional operator produces the following bytecode. 
Note the double use of `checkcast`. 
This is possible given that the `checkcast` instruction is idempotent. 
 
#+BEGIN_SRC java 
Object s = "Ciao"; 
Object t = "Hola"; 
return (String)(arg ? s : t); 
#+END_SRC 
 
#+BEGIN_EXAMPLE 
 0: ldc           #2                  // String Ciao 
 2: astore_1 
 3: ldc           #3                  // String Hola 
 5: astore_2 
 6: iload_0 
 7: ifeq          14 
10: aload_1 
11: goto          15 
14: aload_2 
15: checkcast     #4                  // class java/lang/String 
18: checkcast     #4                  // class java/lang/String 
21: areturn 
#+END_EXAMPLE 

** Old Stuff Bytecode SQL DB :noexport:

We have analyzed 88GB of \ext{jar} files under the Maven Central Repository. 
We have used the last version of each artifact in the Maven Repository. 
This a representative of the artifact itself. 
 
The *Bytecode* column refer to either an cast related instruction or exception. 
These are the cast related bytecodes: 
 
*checkcast* as specified by: 
[fn::https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html\#jvms-6.5.checkcast] 
 
*instanceof* as specified by: 
[fn::https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html\#jvms-6.5.instanceof] 
 
*ClassCastException* as specified by: 
[fn::https://docs.oracle.com/javase/7/docs/api/java/lang/ClassCastException.html] 
 
The following two columns indicates how many bytecode where found in: 
- *local* 
My local machine. 
This machine contains a *partial* download of a current snapshot of Maven Central. 
Re-download all the artifacts is in progress. 
- *fermat* 
fermat.inf.usi.ch machine. 
This machine contains an old snapshot of Maven Central (2015)  
 
We carry out our analysis at the bytecode level on the Maven Repository. 
Since we are not interested in the artifacts evolution, 
for our analysis we used the last version of each artifact. 
In total we have analysed *88GB* of compressed `.jar` files. 

* IN-THE-PAPER Casts Usage Patterns
:PROPERTIES:
:header-args: :pretty
:COLUMNS: %ITEM(Pattern) %count(Count) %relations(Relations) %inspection-cast(Casts) %inspection-instanceof(~instanceof~ s) %inspection-getclass(getClass)
:END:
:LOGBOOK:
- State "IN-THE-PAPER" from "DRAFT"      [2018-03-02 Fri 11:32]
- State "DRAFT"      from "TODO"       [2018-01-19 Fri 13:48] \\
  Include format for patterns.
:END:
<<sec:patterns>>

In this section we present the cast usage patterns we found.
Each pattern has the following sections:

- Description. :: Tells what is this pattern about.
- Snippet. :: Gives one or more concrete examples found in real code.[fn::Please notice that the snippets presented here were slightly modified for formatting purposes.] For each snippet, we provide the link back where we found it.
- Detection. :: Shows the \ql{} query used to detect the pattern. All the snippets presented in the section above were detected using the queries presented in this section.
- Discussion. :: Presents suggestions, flaws, or comments.

#  - Rationale :: Why this pattern needs to use a cast.

** IN-THE-PAPER \pname{Typecase}
:PROPERTIES:
:inspection-cast: 65
:inspection-instanceof: 55
:count:    11
:END:
:LOGBOOK:
- State "IN-THE-PAPER" from "DRAFT"      [2018-01-20 Sat 13:33]
- State "DRAFT"      from "TODO"       [2018-01-20 Sat 13:33] \\
  To discuss
:END:

*** Description
:PROPERTIES:
:UNNUMBERED: t
:END:

This pattern is composed of a guard (~instanceof~) followed by a cast on known subtypes of the static type.
Often there is just one case and the default case (/i.e./, ~instanceof~ fails) does a /no-op/ or reports an error.

# 11 of the casts here are checked against application-specific type tags rather than instanceof.
# The one case typecase is possibly the same as family polymorphism. 

*** Snippet
:PROPERTIES:
:UNNUMBERED: t
:END:

Listing [[lst:snippet:typecase]] [fn::https://lgtm.com/projects/g/neo4j/neo4j/snapshot/70dade422c3a6f502e03b636432ee10c12308dd6/files/community/bolt/src/main/java/org/neo4j/bolt/transport/SocketTransportHandler.java?sort=name&dir=ASC&mode=heatmap&showExcluded=false#L59]
shows an example of the \pname{Typecase} pattern.

#+NAME: lst:snippet:typecase 
#+CAPTION: Example of the \pname{Typecase} pattern.
#+ATTR_LATEX: :options style=java
#+BEGIN_SRC java
@Override
public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
    if (msg instanceof ByteBuf) {
        ByteBuf buffer = (ByteBuf) msg;
        if (protocol == null) {
            chooseProtocolVersion(ctx, buffer);
        }
        else {
            protocol.handle(ctx, buffer);
        }
    }
    else {
        ctx.fireChannelRead(msg);
    }
}
#+END_SRC

*** Detection
:PROPERTIES:
:UNNUMBERED: t
:END:

Listing [[lst:detection:typecase]] shows the detection query for the \pname{Typecase} pattern.
This detection query looks for a cast guarded by an ~instanceof~.

#+NAME: lst:detection:typecase 
#+CAPTION: Detection of the \pname{Typecase} pattern.
#+ATTR_LATEX: :options style=ql
#+BEGIN_SRC ql
import java

from InstanceOfExpr ioe, CastExpr ce
where ce.getTypeExpr().getType() = ioe.getTypeName().getType()
  and ce.getExpr().getType() = ioe.getExpr().getType()
  and ioe.getBasicBlock().bbDominates(ce.getBasicBlock())
select ioe, ce
#+END_SRC

*** Discussion
:PROPERTIES:
:UNNUMBERED: t
:END:

The \pname{Typecase} pattern can be seen as an /ad-hoc/ alternative to pattern matching.
This construct can be seen in several other languages, /e.g./, \haskell{}, \scala{}, and \cs{}.
There is an ongoing proposal[fn::http://openjdk.java.net/jeps/305] to add pattern matching to the \java{} language.

As a workaround, alternatives to the \pname{Typecase} pattern can be the visitor pattern or polymorphism.
But in some cases, the chain of ~instanceof~ s is of boxed types.
Thus no polymorphism can be used.

It was taken from a \lgtm{} rule[fn::https://lgtm.com/rules/910065/].

#+NAME: lst:detection:typecase2
#+CAPTION: Detection of the \pname{Typecase} pattern.
#+ATTR_LATEX: :options style=ql
#+BEGIN_SRC ql
import java

int instanceofCountForIfChain(IfStmt is) {
  exists(int rest | (
      if is.getElse() instanceof IfStmt
      then rest = instanceofCountForIfChain(is.getElse())
      else rest = 0
    ) and (
      if is.getCondition() instanceof InstanceOfExpr
      then result = 1 + rest
      else result = rest
    )
  )
}

from IfStmt is, int n
where n = instanceofCountForIfChain(is) and n > 0
  and not exists(IfStmt other | is = other.getElse())
select is, n
#+END_SRC

*** CANCELED Snippet not for this pattern                        :noexport:
CLOSED: [2018-03-06 Tue 14:09]
:LOGBOOK:
- State "CANCELED"   from "DRAFT"      [2018-03-06 Tue 14:09]
- State "DRAFT"      from "CANCELED"   [2018-03-06 Tue 14:07] \\
  removed
:END:

Same method invocation in two different static types.

#+ATTR_LATEX: :options style=java
#+BEGIN_SRC java 
public void add(String key, String value) { 
    if (key != null && value != null) { 
        Object params = urlParamsWithObjects.get(key); 
        if (params == null) { 
            // Backward compatible, which will result in "k=v1&k=v2&k=v3" 
            params = new HashSet<String>(); 
            this.put(key, params); 
        } 
        if (params instanceof List) { 
            ((List<Object>) params).add(value); 
        } else if (params instanceof Set) { 
            ((Set<Object>) params).add(value); 
        } 
    } 
} 
#+END_SRC 

** IN-THE-PAPER \pname{Lookup by ID} /a.k.a./ Heterogeneous Collection
:PROPERTIES:
:inspection-cast: 135
:count:    3
:relations: unguarded
:END:
:LOGBOOK:
- State "IN-THE-PAPER" from "DRAFT"      [2018-02-28 Wed 14:46]
- State "DRAFT"      from "IN-THE-PAPER" [2018-02-27 Tue 16:10] \\
  Note that Easily confused with object in collection so need to revisit usages of both.
- State "IN-THE-PAPER" from              [2018-01-20 Sat 13:31]
:END:

*** Description
:PROPERTIES:
:UNNUMBERED: t
:END:

Lookup an object by ID, tag or name and cast the result (it is used often in Android code).
It accesses a collection that holds values of different types
(usually implemented as ~Collection<Object>~ or as ~Map<K, Object>~).

*** Snippet
:PROPERTIES:
:UNNUMBERED: t
:END:

In the example shown in listing [[lst:snippet:lookupid]]
[fn::https://lgtm.com/projects/g/loopj/android-async-http/snapshot/dist-1879340034-1518514025554/files/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java?sort=name&dir=ASC&mode=heatmap&excluded=false#L258],
the ~getAttribute~ method returns ~Object~.
The variable ~context~ is of type ~BasicHttpContext~,
which is implemented with ~HashMap~.

#+NAME: lst:snippet:lookupid 
#+CAPTION: Example of the \pname{Lookup by ID} pattern.
#+ATTR_LATEX: :options style=java
#+BEGIN_SRC java
~AuthState~ `authState` =
    (~AuthState~)`context`.|getAttribute|(~ClientContext~.^TARGET_AUTH_STATE^); 
#+END_SRC

*** Detection
:PROPERTIES:
:UNNUMBERED: t
:END:

The \ql{} query to detect this pattern is shown in listing [[lst:detection:lookup]].
Notice that we check for the argument to be static final (constant).

#+NAME: lst:detection:lookup
#+CAPTION: Detection of the \pname{Lookup by id} pattern.
#+ATTR_LATEX: :options style=ql
#+BEGIN_SRC ql
import java

from CastExpr ce, MethodAccess ma, FieldAccess fa
where ma = ce.getExpr() and
    not ma.getMethod().isStatic() and not ma.getMethod().isVarargs() and
    ma.getMethod().isPublic() and 
    ma.getMethod().getNumberOfParameters() = 1 and
    ma.getMethod().getParameterType(0).getTypeDescriptor() = "Ljava/lang/String;" and
    ma.getMethod().getReturnType().getTypeDescriptor() = "Ljava/lang/Object;" and
    ma.getArgument(0).getType().getTypeDescriptor() = "Ljava/lang/String;" and
    ma.getArgument(0) = fa and
    fa.getField().isFinal() and fa.getField().isStatic() and //fa.getField().isPublic() and
    fa.getField().getType().getTypeDescriptor() = "Ljava/lang/String;" // Double-check
select ce, "Expression is " + ce + " " + fa.getField().pp()
#+END_SRC

*** Discussion
:PROPERTIES:
:UNNUMBERED: t
:END:

This pattern suggests an heterogeneous dictionary.
Given our manual inspection,
we believe that all dictionary keys and resulting types are known at compile-time, /i.e./, by the programmer.
But in any case a cast is needed given the restriction of the type system.
As a complementary analysis,
it would be interesting to check whether all call sites to ~getAttribute~ receives a constant (~final static~ field).

Notice that this pattern is not guarded by an ~instanceof~.
However, the cast involved does not fail at runtime.
This means that the source of the cast is known to the programmer.
This raises the following questions:
- /What kind of analysis is needed to detect the source of the cast?/
- /Is worth to have it?/
- /Is better to change API?/
- /How other --- statically typed --- languages support this kind of idiom?/
- /Could generative programming a.k.a. templates solve this problem?/

** IN-THE-PAPER \pname{Null}
:PROPERTIES:
:inspection-cast: 11
:count:    37
:END:
:LOGBOOK:
- State "IN-THE-PAPER" from              [2018-01-20 Sat 14:45]
:END:

*** Description
:PROPERTIES:
:UNNUMBERED: t
:END:

A cast to ~null~ is used to resolve method overloading ambiguity.
Whenever a ~null~ value needs to be an argument of an overloaded method
[fn::Using ad-hoc polymorphism cite:strachey_fundamental_2000]
and two or more of its implementations differ /only/ in their argument type,
a cast is needed to select the appropriate implementation.
This is because the type of ~null~ has the special type /null/
[fn::https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.1]
which can be treated as any reference type.
In this case, the compiler cannot determine which method implementation to select.

*** Snippet
:PROPERTIES:
:UNNUMBERED: t
:END:

Listing [[lst:snippet:null]]
[fn::https://lgtm.com/projects/g/loopj/android-async-http/snapshot/dist-1879340034-1518514025554/files/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java?sort=name&dir=ASC&mode=heatmap&excluded=false#L150]
shows an example of \pname{Null} pattern.

#+NAME: lst:snippet:null
#+CAPTION: Example of \pname{Null} pattern.
#+ATTR_LATEX: :options style=java
#+BEGIN_SRC java 
|onSuccess|(`statusCode`, `headers`, (~String~) null); 
#+END_SRC

In this example, there are three versions of the ~onSuccess~ method, as shown in listing [[lst:snippet:null:defs]].
The cast ~(String) null~ is used to select the appropriate version (line 7), based on the third parameter.

#+NAME: lst:snippet:null:defs
#+CAPTION: Overloaded methods that differ only in their argument type (the third one).
#+ATTR_LATEX: :options style=java
#+BEGIN_SRC java
public void onSuccess(
      int statusCode, Header[] headers, JSONObject response) {...}

public void onSuccess(
      int statusCode, Header[] headers, JSONArray response) {...}

public void onSuccess(
      int statusCode, Header[] headers, String responseString) {...}
#+END_SRC

*** Detection
:PROPERTIES:
:UNNUMBERED: t
:END:

Listing [[lst:detection:null]] shows how to detect this pattern.
This pattern shows up when a cast is directly applied to the ~null~ constant.

#+NAME: lst:detection:null
#+CAPTION: Detection of the \pname{Null} pattern.
#+ATTR_LATEX: :options style=ql
#+BEGIN_SRC ql
import java

from CastExpr ce, NullLiteral nl
where ce.getExpr() = nl
select ce
#+END_SRC

*** Discussion
:PROPERTIES:
:UNNUMBERED: t
:END:

Casting the ~null~ constant seems rather artificial.
This pattern shows either a lack of expressiveness in \java{} or a bad API design.

Several other languages support default parameters, /e.g./, \scala{}, \cs{} and \cpp{}.
Adding default parameters might be a partial solution.

** IN-THE-PAPER \pname{Equals}
:PROPERTIES:
:inspection-cast: 18
:inspection-instanceof: 6
:inspection-getclass: 12
:relations: typecase, guarded
:count:    254
:END:
:LOGBOOK:
- State "IN-THE-PAPER" from "TODO"       [2018-01-20 Sat 14:41]
:END:

*** Description
:PROPERTIES:
:UNNUMBERED: t
:END:

A cast expression is guarded by either an ~instanceof~ test or a ~getClass~ comparison (to the same target type as the cast);
in an ~equals~ [fn:: [[https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals-java.lang.Object-]] ]
method implementation.
This is done to check if the argument has same type as the receiver (~this~ argument).

Notice that a cast in an ~equals~ method is needed because it receives an ~Object~ as a parameter.

*** Snippet
:PROPERTIES:
:UNNUMBERED: t
:END:

Listing [[lst:snippet:equals:instanceof]] [fn::https://lgtm.com/projects/g/neo4j/neo4j/snapshot/dist-15760049-1519892555006/files/community/kernel/src/main/java/org/neo4j/kernel/impl/api/CountsRecordState.java?sort=name&dir=ASC&mode=heatmap&excluded=false#L182]
shows an example of the \pname{Equals} pattern.
In this case, ~instanceof~ is used to guard for the same type as the receiver.

#+NAME: lst:snippet:equals:instanceof
#+CAPTION: Example of the \pname{Equals} pattern using ~instanceof~ as a guard.
#+ATTR_LATEX: :options style=java
#+BEGIN_SRC java
@Override
public boolean equals(Object obj) {
    if ( this == obj ) {
        return true;
    }
    if ( (obj instanceof Difference) ) {
        Difference that = (Difference) obj;
        return actualFirst == that.actualFirst
                && expectedFirst == that.expectedFirst
                && actualSecond == that.actualSecond 
                && expectedSecond == that.expectedSecond
                && key.equals( that.key );
    }
    return false;
}
#+END_SRC

Alternatively, listing [[lst:snippet:equals:getclass]] [fn::https://lgtm.com/projects/g/neo4j/neo4j/snapshot/dist-15760049-1519892555006/files/community/bolt/src/main/java/org/neo4j/bolt/v1/messaging/infrastructure/ValuePath.java?sort=name&dir=ASC&mode=heatmap&excluded=false#L278]
shows another example of the \pname{Equals} pattern.
But in this case, a ~getClass~ comparison is used to guard for the same type as the receiver.

#+NAME: lst:snippet:equals:getclass
#+CAPTION: Example of the \pname{Equals} pattern guarded by a ~getClass~ comparison.
#+ATTR_LATEX: :options style=java
#+BEGIN_SRC java
@Override
public boolean equals( Object o ) {
    if ( this == o ) return true;
    if ( o == null || getClass() != o.getClass() ) return false;

    ValuePath that = (ValuePath) o;
    return nodes.equals(that.nodes) && relationships.equals(that.relationships);
}

#+END_SRC

*** Detection
:PROPERTIES:
:UNNUMBERED: t
:END:

Listing [[lst:detection:equals]] shows how the \pname{Equals} pattern is detected.
The detection query looks for a cast expression inside an ~equals~ method implementation.
Moreover, the cast needs to be guarded by either an ~instanceof~ test or a ~getClass~ comparison.

#+NAME: lst:detection:equals
#+CAPTION: Detection of \pname{Equals} pattern.
#+ATTR_LATEX: :options style=ql
#+BEGIN_SRC ql
import java

predicate isGetClassAccess(MethodAccess ma) {
  ma.getMethod().getName() = "getClass" and 
  ma.getMethod().getNumberOfParameters() = 0 and 
  exists (TypeClass tc | ma.getMethod().getReturnType() = tc)
}

predicate isGuardedByGetClass(CastExpr ce, EqualsMethod eqm) {
  exists (EqualityTest eqe, MethodAccess tma, MethodAccess oma |
    isGetClassAccess(tma) and isGetClassAccess(oma) and
    not tma.hasQualifier() and
    oma.getQualifier() = eqm.getParameter().getAnAccess() and
    eqe.hasOperands(tma, oma) and
    eqe.getEnclosingCallable() = eqm and
    eqe.getBasicBlock().bbDominates(ce.getBasicBlock())
  )
}

predicate isGuardedByInstanceOf(CastExpr ce, EqualsMethod eqm) {
  exists (InstanceOfExpr ioe | 
    ioe.getEnclosingCallable() = eqm and
    ioe.getExpr() = eqm.getParameter().getAnAccess() and
    ioe.getTypeName().getType() = eqm.getDeclaringType()
    and ioe.getBasicBlock().bbDominates(ce.getBasicBlock())
  )
}

from CastExpr ce, EqualsMethod eqm
where ce.getEnclosingCallable() = eqm 
  and ce.getExpr() = eqm.getParameter().getAnAccess()
  and ce.getTypeExpr().getType() = eqm.getDeclaringType() 
  and ( isGuardedByGetClass(ce, eqm) or isGuardedByInstanceOf(ce, eqm) )
select ce, eqm
#+END_SRC

*** Discussion
:PROPERTIES:
:UNNUMBERED: t
:END:

The pattern for an ~equals~ method implementation is well-known.
We have started looking at all ~equals~ methods with the following \ql{} query:

#+CAPTION: Fetching all ~equals~ method implementations.
#+ATTR_LATEX: :options style=ql
#+BEGIN_SRC ql
import java

from EqualsMethod eqm
select eqm
#+END_SRC

We found out that, with respect to cast, most ~equals~ methods are implemented with the same structure.
Maybe avoid boilerplate code by providing code generation, like in \haskell{} (with ~deriving~).

citet:vaziri_declarative_2007 proposes a declarative approach to avoid boilerplate code when implementing both the ~equals~ and ~hashCode~ methods.
They manually analyzed several applications, and found many issues while implementing ~equals()~ and ~hashCode()~ methods.
It would be interesting to check whether these issues happen in real application code.

There is an exploratory document[fn::http://cr.openjdk.java.net/~briangoetz/amber/datum.html] by Brian Goetz --- \java{} Language Architect --- 
addressing these issues from a more general perspective.
It is definitely a starting point towards improving the \java{} language.

*** CANCELED Detection Related                                   :noexport:
CLOSED: [2018-03-06 Tue 14:10]

#+BEGIN_SRC ql
import java

from CastExpr ce, EqualsMethod eqm
where ce.getEnclosingCallable() = eqm
select eqm
#+END_SRC

Related to equals
This is a rule.

#+BEGIN_SRC ql
import java

from RefType t, Method equals
where t.fromSource() and
      equals = t.getAMethod() and
      equals.hasName("equals") and 
      equals.getNumberOfParameters() = 1 and 
      not t.getAMethod() instanceof EqualsMethod
select equals, "To override the equals method, the parameter "
               + "must be of type java.lang.Object."
#+END_SRC
 
** IN-THE-PAPER \pname{Clone}
:PROPERTIES:
:inspection-cast: 2
:count:    2
:END:
:LOGBOOK:
- State "IN-THE-PAPER" from              [2018-01-20 Sat 14:48]
:END:
 
*** Description
:PROPERTIES:
:UNNUMBERED: t
:END:

Cast the result of the ~clone~[fn::[[https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#clone--]]]
method defined in a super class within a ~clone~ method implementation.
 
*** Snippet
:PROPERTIES:
:UNNUMBERED: t
:END:

Listing [[lst:snippet:clone]] shows an example of the \pname{Clone} pattern.

#+NAME: lst:snippet:clone
#+CAPTION: Example of the \pname{Clone} pattern.
#+ATTR_LATEX: :options style=java
#+BEGIN_SRC java
@Override
public Extractor<T> clone() {
    try {
        return (Extractor<T>) super.clone();
    }
    catch (CloneNotSupportedException e) {
        throw new AssertionError(Extractor.class.getName() + " implements " +
                Cloneable.class.getSimpleName() +
                ", at least this implementation assumes that. " +
                "This doesn't seem to be the case anymore", e );
    }
}
#+END_SRC

*** Detection
:PROPERTIES:
:UNNUMBERED: t
:END:

The detection for this pattern looks for a cast within an implementation of a ~clone~ method.
This is shown in listing [[lst:detection:clone]].

#+NAME: lst:detection:clone
#+CAPTION: Detection of the \pname{Clone} pattern.
#+ATTR_LATEX: :options style=ql
#+BEGIN_SRC ql
import java

from CastExpr ce, CloneMethod cm, SuperMethodAccess sma, CloneMethod cma
where ce.getEnclosingCallable() = cm
  and ce.getExpr() = sma
  and sma.getMethod() = cma
select cm
#+END_SRC

*** Discussion
:PROPERTIES:
:UNNUMBERED: t
:END:

We have used the same approach as for the \pname{Equals} pattern.
We started looking for all ~clone~ method implementations using the following \ql{} query:

#+CAPTION: Fetching all ~clone~ methods implementations.
#+ATTR_LATEX: :options style=ql
#+BEGIN_SRC ql
import java

from CloneMethod cm
select cm
#+END_SRC

A common ~clone~ implementation, however, looks like the following,[fn::https://lgtm.com/projects/g/neo4j/neo4j/snapshot/70dade422c3a6f502e03b636432ee10c12308dd6/files/community/kernel/src/main/java/org/neo4j/kernel/impl/api/index/IndexMap.java?sort=name&dir=ASC&mode=heatmap&excluded=false#L91]
which it does not include any cast operator.

#+BEGIN_SRC java
@Override
public IndexMap clone() {
    return new IndexMap(cloneMap(indexesById), cloneMap(indexesByDescriptor));
}
#+END_SRC

This pattern suffers the same issues as the \pname{Equals} pattern.
 
** IN-THE-PAPER \pname{newInstance}
:PROPERTIES:
:inspection-cast: 5
:inspection-instanceof: 1
:count:    23
:END:
:LOGBOOK:
- State "IN-THE-PAPER" from "TODO"       [2018-03-26 Mon 15:16]
- State "IN-THE-PAPER" from              [2018-01-20 Sat 19:02]
:END:

*** Description
:PROPERTIES:
:UNNUMBERED: t
:END:

The ~newInstance~ method family declared in the ~Class~[fn::[[https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#newInstance--]]],
~Array~[fn::[[https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Array.html#newInstance-java.lang.Class-int-]]]$^{,}$
[fn::[[https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Array.html#newInstance-java.lang.Class-int...-]]] and 
~Constructor~[fn::[[https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Constructor.html#newInstance-java.lang.Object...-]]]
classes creates an object or array by means of reflection.

This pattern consists of casting the result of these methods to the appropriate target type.
 
*** Snippet
:PROPERTIES:
:UNNUMBERED: t
:END:

The following example shows a cast from the ~Class.newInstance()~ method[fn::https://lgtm.com/projects/g/apache/hadoop/snapshot/6bedbef6c5f2d937a6cbc268300ce2a39609d06c/files/hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java?sort=name&dir=ASC&mode=heatmap&showExcluded=false#L1039].

#+NAME: lst:snippet:newinstance-class
#+CAPTION: Example of the \pname{newInstance} pattern using the ~Class~ class.
#+ATTR_LATEX: :options style=java
#+BEGIN_SRC java
logger = (AuditLogger) Class.forName(className).newInstance();
#+END_SRC

The following example shows how to dynamically create an array[fn::https://lgtm.com/projects/g/neo4j/neo4j/snapshot/27aaa67633e4d26446e38125d04fbbd27f938b75/files/community/collections/src/main/java/org/neo4j/helpers/collection/Iterables.java?sort=name&dir=ASC&mode=heatmap&showExcluded=false#L403].

#+NAME: lst:snippet:newinstance-array
#+CAPTION: Example of the \pname{newInstance} pattern using the ~Array~ class.
#+ATTR_LATEX: :options style=java
#+BEGIN_SRC java
return list.toArray( (T[]) Array.newInstance( componentType, list.size()));
#+END_SRC

Whenever a constructor other than the default constructor is needed,
the ~newInstance~ method declared in the ~Constructor~ class should be used to select the appropriate constructor,
as shown in the following example.[fn::https://lgtm.com/projects/g/gradle/gradle/snapshot/209c3175e75af6ac30cb66c02eda15b0f8b6a616/files/subprojects/internal-integ-testing/src/main/groovy/org/gradle/integtests/fixtures/executer/OutputScrapingExecutionFailure.java?sort=name&dir=ASC&mode=heatmap&showExcluded=false#L174]

#+NAME: lst:snippet:newinstance-ctor
#+CAPTION: Example of the \pname{newInstance} pattern using the ~Constructor~ class.
#+ATTR_LATEX: :options style=java
#+BEGIN_SRC java
return (Exception) Class
                       .forName(className)
                       .getConstructor(String.class)
                       .newInstance(message);
#+END_SRC

*** Detection
:PROPERTIES:
:UNNUMBERED: t
:END:

This detection query looks for casts, where the expression being cast is a call site to methods mentioned above.

#+NAME: lst:detection:newinstance
#+CAPTION: Fetching all casts to ~newInstance()~.
#+ATTR_LATEX: :options style=ql
#+BEGIN_SRC ql
import java

predicate isByReflection(string qname) {
  qname = "java.lang.reflect.Array" or 
  qname = "java.lang.Class<?>" or 
  qname = "java.lang.reflect.Constructor<?>"
}

from CastExpr ce, MethodAccess ma, Method m
where ma = ce.getExpr()
  and m = ma.getMethod()
  and m.getName() = "newInstance"
  and isByReflection(m.getDeclaringType().getQualifiedName())
select ce, m.getDeclaringType().getQualifiedName()
#+END_SRC

*** Discussion
:PROPERTIES:
:UNNUMBERED: t
:END:

The cast here is needed because of the dynamic essence of reflection.

** IN-THE-PAPER \pname{Redundant Cast}
:PROPERTIES:
:inspection-cast: 6
:count:    0
:END:
:LOGBOOK:
- State "IN-THE-PAPER" from "TODO"       [2018-03-26 Mon 19:49]
- State "IN-THE-PAPER" from              [2018-01-20 Sat 15:18]
:END:

*** Description
:PROPERTIES:
:UNNUMBERED: t
:END:

A redundant cast is a cast or ~instanceof~ test that always succeed based on the static type.

*** Snippet
:PROPERTIES:
:UNNUMBERED: t
:END:

The following example shows a redundant cast.[fn::https://lgtm.com/projects/g/gradle/gradle/snapshot/209c3175e75af6ac30cb66c02eda15b0f8b6a616/files/subprojects/wrapper/src/main/java/org/gradle/wrapper/BootstrapMainStarter.java?sort=name&dir=ASC&mode=heatmap&showExcluded=false#L32]
The ~instanceof~ tests is done in line 8 against the ~contextClassLoader~ variable.
However, notice its definition in line 1 as ~URLClassLoader~ (which implements ~Closeable~.
The test will always succeed, being a redundant cast.

#+NAME: lst:snippet:redundant
#+CAPTION: Example of the \pname{Redundant Cast} pattern.
#+ATTR_LATEX: :options style=java
#+BEGIN_SRC java
URLClassLoader contextClassLoader = new URLClassLoader(
               new URL[]{gradleJar.toURI().toURL()},
               ClassLoader.getSystemClassLoader().getParent());
Thread.currentThread().setContextClassLoader(contextClassLoader);
Class<?> mainClass = contextClassLoader.loadClass("org.gradle.launcher.GradleMain");
Method mainMethod = mainClass.getMethod("main", String[].class);
mainMethod.invoke(null, new Object[]{args});
if (contextClassLoader instanceof Closeable) {
    ((Closeable) contextClassLoader).close();
}
#+END_SRC
 
*** Detection
:PROPERTIES:
:UNNUMBERED: t
:END:

This detection pattern is already a \lgtm{} rule.[fn::https://lgtm.com/rules/2970081/]

#+NAME: lst:detection:redundant
#+CAPTION: Fetching all redundant casts.
#+ATTR_LATEX: :options style=ql
#+BEGIN_SRC ql
import java

from InstanceOfExpr ioe, RefType t, RefType ct
where t = ioe.getExpr().getType()
  and ct = ioe.getTypeName().getType()
  and ct = t.getASupertype+()
select ioe, "There is no need to test whether an instance of $@ is also an instance of $@ - it always is.",
  t, t.getName(),
  ct, ct.getName()
#+END_SRC

*** Discussion

This is a cast that should always succeed based on the static type. 
Some of these seem to be because some of the types changed during a refactoring and the cast was not removed.
It can be placed maybe for documentation purposes.

** TODO Family Polymorphism :noexport:
:PROPERTIES:
:inspection-cast: 56 (25 potential)
:END:

*** Description
:PROPERTIES:
:UNNUMBERED: t
:END:

Two or more mutually dependent classes are subtyped, but fields or method parameters in the base class cannot be overridden in the subtype to use the derived types. 
Also includes casting to "internal" classes. 
Also includes casting "context" objects to a subtype. 
Usually unchecked (16 instanceofs classified as typecase or argument check are related to the cast in this pattern, so maybe should be reclassified). 
Includes also some "quasi reflection" calls to the java annotation processing API. 

** DRAFT Factory Method :noexport:
:PROPERTIES:
:inspection-cast: 26 (24 redundant)
:relations: redundant
:END:
:LOGBOOK:
- State "DRAFT"      from "TODO"       [2018-01-20 Sat 14:40] \\
  detection
:END:
 
*** Description
:PROPERTIES:
:UNNUMBERED: t
:END:

Cast factory method result to subtype (special case of family polymorphism).
Usually Logger.getLogger.

Specific for Logger.getLogger()

*** Snippet
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC java
public static Logger getLogger(Class c) {
  return (Logger) LoggerFactory.getLogger(c);
}
#+END_SRC

*** Discussion
:PROPERTIES:
:UNNUMBERED: t
:END:

In this case the cast is redundant (already ~getLogger~ returns ~Logger~).

*** Detection
:PROPERTIES:
:UNNUMBERED: t
:END:

Only for logger. How to detect a factory method?

#+BEGIN_SRC ql
import java

from CastExpr ce, MethodAccess ma
where ce.getExpr() = ma and ma.getMethod().getName() = "getLogger"
select ce, ma, ma.getQualifier()
#+END_SRC

** DRAFT Search or filter by type :noexport:
:PROPERTIES:
:inspection-cast: 11
:inspection-instanceof: 9
:count:    693
:END:
:LOGBOOK:
- State "DRAFT"      from              [2018-01-22 Mon 22:15] \\
  Detection
:END:

*** Description
:PROPERTIES:
:UNNUMBERED: t
:END:

Search or filter a collection by inspecting the types (and often other properties) of the objects in the collection.
Note the collection could be an ad-hoc linked list too. 
 
*** Detection
:PROPERTIES:
:UNNUMBERED: t
:END:

Looking for casts inside a loop.

#+BEGIN_SRC ql
import java

from CastExpr ce, LoopStmt ls
where ls.getAChild*() = ce.getEnclosingStmt()
select ce, ls
#+END_SRC

** TODO Composite container object :noexport:
:PROPERTIES:
:inspection-cast: 16
:END:

*** Description
:PROPERTIES:
:UNNUMBERED: t
:END:

The container or parent of an object in some composite should be a particular type, cast to it.
 
** DRAFT Testing :noexport:
:PROPERTIES:
:inspection-instanceof: 13
:inspection-cast: 3
:count:    840
:END:
:LOGBOOK:
- State "DRAFT"      from              [2018-01-31 Wed 09:36] \\
  count
:END:

*** Description
:PROPERTIES:
:UNNUMBERED: t
:END:

instanceof in a test (did a method under test create the right object?), or uses getClass, then might cast to access fields.
 
*** Detection
:PROPERTIES:
:UNNUMBERED: t
:END:

More precision needed.

#+BEGIN_SRC ql
import java

from CastExpr ce, TestMethod tm, RefType rt
where ce.getEnclosingCallable() = tm and ce.getType() = rt
select ce, tm
#+END_SRC

** TODO Query Result :noexport:
:PROPERTIES:
:inspection-cast: 11
:END:

*** Description
:PROPERTIES:
:UNNUMBERED: t
:END:

Cast a query result (either SQL query or XPath or application-specific) 
 
** TODO Payload :noexport:
:PROPERTIES:
:inspection-cast: 10
:relations: typecase
:END:

*** Description
:PROPERTIES:
:UNNUMBERED: t
:END:

Cast access to message payload (usually Object) 
6 or 10 instances that use a type tag to check the message type and cast to the right pattern --
maybe these cases should be considered typecase.
 
*** Snippet
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC java 
                case FAILURE_MESSAGE: 
                    response = (Object[]) message.obj; 
                    if (response != null && response.length >= 4) { 
                        onFailure((Integer) response[0], (Header[]) response[1], (byte[]) response[2], (Throwable) response[3]); 
                    } else { 
                        AsyncHttpClient.log.e(LOG_TAG, "FAILURE_MESSAGE didn't got enough params"); 
                    } 
                    break; 
#+END_SRC 
 
** DRAFT Lookup by type tag                                       :noexport:
:PROPERTIES:
:inspection-cast: 9
:relations: typecase
:count:    15
:END:
:LOGBOOK:
- State "DRAFT"      from "IN-THE-PAPER" [2018-02-28 Wed 14:47] \\
  No export for now
- State "IN-THE-PAPER" from              [2018-01-20 Sat 15:18]
:END:

*** Description
:PROPERTIES:
:UNNUMBERED: t
:END:

Lookup in a collection using a application-specific type tag or a java.lang.Class 
 
*** Detection
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC ql
import java

from CastExpr ce, SwitchStmt ss, RefType rt
where ce.getType() = rt and exists(int n | ce.getEnclosingStmt() = ss.getStmt(n))
select ss
#+END_SRC

** DRAFT Argument check :noexport:
:PROPERTIES:
:inspection-instanceof: 6
:inspection-cast: 3
:relations: equals
:count:    207
:END:
:LOGBOOK:
- State "DRAFT"      from              [2018-01-30 Tue 15:24] \\
  count
:END:
 
*** Description
:PROPERTIES:
:UNNUMBERED: t
:END:

Check that method argument has expected type
(subtype of declared type) typically in overridden methods. 

*** Detection
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC ql
import java

from InstanceOfExpr ioe, CastExpr ce, Method m, Method d, Parameter p
where ioe.getExpr() = p.getAnAccess() and ce.getExpr() = p.getAnAccess() and
  m = ce.getEnclosingCallable() and m.overrides(d)
select ce, m, d
#+END_SRC
 
** DRAFT Reflection field or invoke :noexport:
:PROPERTIES:
:inspection-instanceof: 1
:inspection-cast: 7
:count:    12
:END:
:LOGBOOK:
- State "DRAFT"      from              [2018-01-31 Wed 09:44] \\
  count
:END:
 
*** Description
:PROPERTIES:
:UNNUMBERED: t
:END:

Cast result of field access or method invocation using reflection. 
 
# repos/android-async-http/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java:445 
 
*** Snippet
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC java
Setting setting = (Setting) field.get( null );
#+END_SRC

#+BEGIN_SRC java 
    public static void endEntityViaReflection(HttpEntity entity) { 
        if (entity instanceof HttpEntityWrapper) { 
            try { 
                Field f = null; 
                Field[] fields = HttpEntityWrapper.class.getDeclaredFields(); 
                for (Field ff : fields) { 
                    if (ff.getName().equals("wrappedEntity")) { 
                        f = ff; 
                        break; 
                    } 
                } 
                if (f != null) { 
                    f.setAccessible(true); 
                    HttpEntity wrapped = (HttpEntity) f.get(entity); 
                    if (wrapped != null) { 
                        wrapped.consumeContent(); 
                    } 
                } 
            } catch (Throwable t) { 
                log.e(LOG_TAG, "wrappedEntity consume", t); 
            } 
        } 
    } 
#+END_SRC 

*** Detection
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC ql
import java

from CastExpr ce, MethodAccess ma
where ce.getExpr() = ma and ma.getQualifier().getType().getTypeDescriptor() = "Ljava/lang/reflect/Field;"
select ce, ma
#+END_SRC

** DRAFT Stash                                                    :noexport:
:PROPERTIES:
:inspection-cast: 8
:count:    193
:END:
:LOGBOOK:
- State "DRAFT"      from "IN-THE-PAPER" [2018-02-28 Wed 14:47] \\
  Not export for now
- State "IN-THE-PAPER" from              [2018-01-20 Sat 16:21]
:END:
 
*** Description
:PROPERTIES:
:UNNUMBERED: t
:END:

Cast access to field of type Object used to stash a value (typically a tag value in a GUI object, or a message payload) 

*** Snippet
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC java
((MenuAnimation) currentFragment).exitFromMenu();
#+END_SRC

*** Detection
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC ql
import java

from CastExpr ce, FieldAccess fa
where ce.getExpr() = fa
select ce, "Expression is " + ce + " " + fa.getField().pp()
#+END_SRC

** DRAFT Object in collection :noexport:
:PROPERTIES:
:inspection-cast: 8
:count:    65
:END:
:LOGBOOK:
- State "DRAFT"      from              [2018-01-31 Wed 10:01] \\
  count
:END:

*** Description
:PROPERTIES:
:UNNUMBERED: t
:END:

Cast when accessing an object from a unparameterized collection object or a collection instantiated on Object rather than a more precise type.
 
Includes one overly complicated use of Java 8 streams.
 
*** Detection

#+BEGIN_SRC ql
import java

from CastExpr ce, MethodAccess ma, RawType rt
where ce.getExpr() = ma and ma.getQualifier().getType() = rt
select ce, ma
#+END_SRC

** TODO Covariant field of supertype :noexport:
:PROPERTIES:
:inspection-cast: 8
:END:

*** Description
:PROPERTIES:
:UNNUMBERED: t
:END:

cast field of supertype which has less-specific type (same as family polymorphism?). 
Often unchecked cast to a subinterface with a presumed type.
 
** DRAFT Return Type Test/instanceof                              :noexport:
:PROPERTIES:
:inspection-cast: 3
:inspection-instanceof: 5
:count:    20
:END:
:LOGBOOK:
- State "DRAFT"      from "IN-THE-PAPER" [2018-02-28 Wed 14:47]
- State "IN-THE-PAPER" from              [2018-01-20 Sat 15:16]
:END:

*** Description
:PROPERTIES:
:UNNUMBERED: t
:END:

Typically just a method wrapping an instanceof 
 
*** Snippet
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC java
private static boolean a(Exception e) {
  return e instanceof RuntimeException;
}
#+END_SRC

*** Discussion
:PROPERTIES:
:UNNUMBERED: t
:END:

How does affect analysis tool?

*** Detection
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC ql
import java

from InstanceOfExpr ie, ReturnStmt rs
where rs.getResult() = ie
select rs, ie
#+END_SRC

** TODO Type parameter :noexport:
:PROPERTIES:
:inspection-cast: 7
:END:

*** Description
:PROPERTIES:
:UNNUMBERED: t
:END:

Unchecked casts to a method type parameter (essentially cast to whatever the caller expects to be returned).
Unchecked casts to class type parameter (simulating a self type).
Casting to T[].

** DRAFT Add type parameters :noexport:
:PROPERTIES:
:inspection-cast: 6
:count:    0
:END:
:LOGBOOK:
- State "DRAFT"      from              [2018-01-31 Wed 12:23] \\
  count
:END:

*** Description
:PROPERTIES:
:UNNUMBERED: t
:END:

Add type parameters to an un-parameterized collection or wildcard collection.
 
*** Detection
:PROPERTIES:
:UNNUMBERED: t
:END:

Zero is correct?

#+BEGIN_SRC ql
import java

from CastExpr ce, GenericType gt
where ce.getTypeExpr().getType() = gt
select ce
#+END_SRC

** DRAFT Remove type parameter :noexport:
:PROPERTIES:
:inspection-cast: 5
:count:    203
:END:
:LOGBOOK:
- State "DRAFT"      from              [2018-01-31 Wed 12:23] \\
  count
:END:

*** Description
:PROPERTIES:
:UNNUMBERED: t
:END:

remove a type parameter from a collection (or java.lang.Class)
or to replace parameter with wildcard.
 
*** Detection
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC ql
import java

from CastExpr ce, RawType rt
where ce.getTypeExpr().getType() = rt
select ce
#+END_SRC

** TODO readObject                                                :noexport:
:PROPERTIES:
:inspection-cast: 4
:count:    3
:END:
:LOGBOOK:
- State "IN-THE-PAPER" from              [2018-01-20 Sat 14:48]
:END:

*** Description
:PROPERTIES:
:UNNUMBERED: t
:END:

cast result of readObject() 
 
*** Example

#+BEGIN_SRC java
private void readObject(ObjectInputStream in)
    throws IOException, ClassNotFoundException {
  String key = (String) in.readObject();
  String value = (String) in.readObject();
  clientCookie = new BasicClientCookie(key, value);
  clientCookie.setComment((String) in.readObject());
  clientCookie.setDomain((String) in.readObject());
  clientCookie.setExpiryDate((Date) in.readObject());
  clientCookie.setPath((String) in.readObject());
  clientCookie.setVersion(in.readInt());
  clientCookie.setSecure(in.readBoolean());
}
#+END_SRC

*** Detection
:PROPERTIES:
:UNNUMBERED: t
:END:

Listing [[lst:detect:readobject]] shows

#+NAME: lst:detect:readobject 
#+CAPTION: Detection of readObject
#+ATTR_LATEX: :options style=ql
#+BEGIN_SRC ql
import java

from CastExpr ce, MethodAccess ma, ReadObjectMethod rom
where ce.getAChildExpr() = ma and ma.getMethod() = rom 
select ma, rom
#+END_SRC

** TODO Exception for rethrow                                     :noexport:
:PROPERTIES:
:inspection-instanceof: 2
:inspection-cast: 2
:count:    40
:relations: typecase
:END:
:LOGBOOK:
- State "TODO"       from "DRAFT"      [2018-02-28 Wed 14:48]
- State "DRAFT"      from              [2018-01-31 Wed 10:27] \\
  detection+count+snippet
:END:
 
*** Description
:PROPERTIES:
:UNNUMBERED: t
:END:

instanceof + cast an exception to RuntimeException or Error to rethrow in handler 

*** Snippet
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC java
catch (Throwable t) {
  if (exceptionOk(t)) {
      itemDodged( nextItem );
      continue;
  }
  if (t instanceof RuntimeException) {
      throw (RuntimeException) t;
  }
  else if (t instanceof Error) {
      throw (Error) t;
  }
  throw new RuntimeException( t );
}
#+END_SRC
 
*** Detection
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC ql
import java

from CastExpr ce, CatchClause cc
where cc.getAChild*() = ce.getEnclosingStmt()
select ce, cc
#+END_SRC

** DRAFT Covariant return :noexport:
:PROPERTIES:
:inspection-cast: 3
:relations: equals, family, clone
:count:    8
:END:
:LOGBOOK:
- State "DRAFT"      from              [2018-01-31 Wed 11:27] \\
  count
:END:
 
*** Description
:PROPERTIES:
:UNNUMBERED: t
:END:

Cast the result of a super call in an overridden method with covariant return.
(see also family polymorphism).
 
*** Detection
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC ql
import java

from CastExpr ce, RefType rt, Method m, Method d, VirtualMethodAccess vma
where ce.getType() = rt and ce.getEnclosingCallable() = m and m.overrides(d) and ce.getExpr() = vma  and vma.isOwnMethodAccess()
select ce, m, d, vma
#+END_SRC

** TODO Result check :noexport:
:PROPERTIES:
:inspection-cast: 1
:inspection-instanceof: 2
:count:    -
:END:

*** Description
:PROPERTIES:
:UNNUMBERED: t
:END:

Check result of a call has the right type.

How check for it?

** TODO Throwable.getCause                                        :noexport:
:PROPERTIES:
:inspection-cast: 2
:count:    1
:END:
:LOGBOOK:
- State "IN-THE-PAPER" from              [2018-01-20 Sat 14:47]
:END:
 
*** Description
:PROPERTIES:
:UNNUMBERED: t
:END:

~Throwable.getCause~ has type ~Throwable~, cast to ~Exception~.

*** Snippet
:PROPERTIES:
:UNNUMBERED: t
:END:

Getting a specific property from a ~Throwable~.

#+ATTR_LATEX: :options style=java
#+BEGIN_SRC java
((TransactionFailureException) e.getCause()).status() == LockSessionExpired;
#+END_SRC

*** Detection
:PROPERTIES:
:UNNUMBERED: t
:END:
 
Need to be more precise?

#+ATTR_LATEX: :options style=ql
#+BEGIN_SRC ql
import java

from CastExpr ce, MethodAccess ma
where ce.getExpr() = ma and 
  ma.getQualifier().getType().getTypeDescriptor() = "Ljava/lang/Throwable;" and
  ma.getMethod().getName() = "getCause"
select ce, ma
#+END_SRC

** TODO Library method returning Object                           :noexport:
:PROPERTIES:
:inspection-cast: 2
:END:
 
*** Description
:PROPERTIES:
:UNNUMBERED: t
:END:

Cast because some library method returns Object (e.g., the version object in Apache JDO). 
Similar to stash? 
 
** TODO Method argument of type Object                            :noexport:
:PROPERTIES:
:inspection-cast: 1
:relations: equals, Argument check
:count:    132
:END:
:LOGBOOK:
- State "TODO"       from "DRAFT"      [2018-02-28 Wed 14:48]
- State "DRAFT"      from              [2018-01-31 Wed 11:20] \\
  count, detection
:END:
 
*** Description
:PROPERTIES:
:UNNUMBERED: t
:END:

Overridden method takes an Object not something more specific.

*** Detection
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC ql
import java

from InstanceOfExpr ioe, CastExpr ce, Method m, Method d, Parameter p
where ioe.getExpr() = p.getAnAccess() and ce.getExpr() = p.getAnAccess() and
  m = ce.getEnclosingCallable() and m.overrides(d) and p.getType() instanceof TypeObject
select ce, m, d
#+END_SRC
 
** TODO URL.openConnection                                        :noexport:
:PROPERTIES:
:inspection-cast: 1
:count:    0
:END:
:LOGBOOK:
- State "IN-THE-PAPER" from              [2018-01-20 Sat 14:46]
:END:
 
*** Description
:PROPERTIES:
:UNNUMBERED: t
:END:

The method is declared to return URLConnection but can return a more specific type based on the URL string. 
Cast to that. 
Should generalize this pattern. 

*** Detection
:PROPERTIES:
:UNNUMBERED: t
:END:

To specific?

#+BEGIN_SRC ql
import java

from CastExpr ce, MethodAccess ma
where ce.getExpr() = ma and 
  ma.getQualifier().getType().getTypeDescriptor() = "Ljava/net/URL;" and 
  ma.getMethod().getName() = "openConnection"
select ce, ma
#+END_SRC
 
** TODO Result of binary operation :noexport:
:PROPERTIES:
:inspection-cast: 1
:count:    -
:END:
 
*** Description
:PROPERTIES:
:UNNUMBERED: t
:END:

Cast result of binary operation to subtype. 

union in set example.
 
** TODO Type parameter resolution                                 :noexport:
:PROPERTIES:
:inspection-cast: 1
:count:    26
:END:
:LOGBOOK:
- State "IN-THE-PAPER" from              [2018-01-20 Sat 16:09]
:END:

*** Description
:PROPERTIES:
:UNNUMBERED: t
:END:

Use reflection to get class object for a type parameter, then cast to Class<T>.
 
*** Snippet
:PROPERTIES:
:UNNUMBERED: t
:END:

Example.

#+CAPTION: Type Parameter Resolution
#+ATTR_LATEX: :options style=java
#+BEGIN_SRC java
public static <T, F> PropertyAccessor<T, F> readableProperty(
    T target, Class<F> returnType, String property
  ) throws NoSuchPropertyException {
  @SuppressWarnings("unchecked")
  Class<T> targetClass = (Class<T>) target.getClass();
  return readableProperty(targetClass, returnType, property);
}
#+END_SRC

*** Detection
:PROPERTIES:
:UNNUMBERED: t
:END:

Need to be more precise?

#+CAPTION: All casts to ~Class~ class.
#+ATTR_LATEX: :options style=ql
#+BEGIN_SRC ql
import java

from CastExpr ce
where ce.getType().getTypeDescriptor() = "Ljava/lang/Class;"
select ce, ce.getType().getTypeDescriptor()
#+END_SRC

** DRAFT Global flag                                              :noexport:
:PROPERTIES:
:inspection-cast: 1
:relations: typecase
:count:    -
:END:
:LOGBOOK:
- State "DRAFT"      from              [2018-01-21 Sun 11:13] \\
  Added description
:END:
 
*** Description
:PROPERTIES:
:UNNUMBERED: t
:END:

Cast to a known demo subclass when running in demo mode. 
This should be some sort of typecase I guess,
but we check a global boolean flag (or a method in a configuration object) rather than a type tag or an instanceof. 