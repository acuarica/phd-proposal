
\chapter{Introduction}

Programming language design has been always a hot topic in computer science literature.
It has been extensively studied in the past decades.
For instance, there is a trend in incorporating functional programming features into mainstream object-oriented languages, \eg{}, lambdas in \java{} 8\footnote{\url{https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html\#jls-15.27}}, \cpp{}11\footnote{\url{http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1968.pdf}} and \cs{} 3.0\footnote{\url{https://msdn.microsoft.com/en-us/library/bb308966.aspx\#csharp3.0overview_topic7}};
or parametric polymorphism in \java{} 5\footnote{\url{https://docs.oracle.com/javase/1.5.0/docs/guide/language/generics.html}}$^{,}$\footnote{\url{http://www.oracle.com/technetwork/java/javase/generics-tutorial-159168.pdf}}.

Adding new features to a language should --- \emph{in theory} --- increase programmers productivity.
But once a language feature is released, little is known about how it is actually used by the developer community.
Therefore, it is extremely difficult to assess how features in a language impact on programmers productivity.
\cite{hanenberg_faith_2010,hanenberg_why_2014} argue that human behavior should be applied to programming language usage and design.

Looking at the aforementioned examples, \cite{mazinanian_understanding_2017} and~\cite{uesbeck_empirical_2016}
studied how developers use lambdas in \java{} and \cpp{} respectively; while \cite{parnin_java_2011,parnin_adoption_2013} did the same for generics in \java{}.
This kind of studies give an insight of the adoption of language features that can drive future direction for the language.

We believe that if we (as a research community) understand what kinds of programs are written, we can use this information to improve several aspect of the software development process.
But how to test it?

\researchquestion{Understanding Java in the Wild?}

\section{What do we want to provide?}

As its core, we believe that understanding how actually language features are
used is paramount.


researchers miss opportunities to improve the state of the art
tool builders use unrealistic assumptions
language designers fail to improve upon their designs
developers are unable to explore efficient and effective use of lambdas.

Understanding how developers make use of language features can be helpful to a broad range audience.
It can aid language designers to improve their languages;
tool builders can make real assumptions;
researchers to better improve the state of the art;
developers can benefit from are unable to explore efficient and effective.

Language designers add features to their languages based
We believe
three specific features, namely
We have divised and we plan to divise language and \api{} patterns in order to properly assess this driving forces.
To understand patterns

In this proposal, we plan to explore
Understanding the Use of Language Features in Java
Supporting informed decisions for these driving forces.
Exploring the usability and feasibility of creating new languages based on empirical studies



Evidence-based language as a long term goal

Mining language features thesis
Title: *Understanding Java in the Wild*
Research Question: Is Java Safe?
Methodological Contribution, to evolve your language
Motivate the umbrella that put together those 3 pillars





\section{Proposal Outline}

In our research proposal we investigate the feasibility of 

Supercompilation for specific domains.

Whether it is worth it

\begin{itemize}

\item Chapter~\ref{cha:literature-review} gives an overview of the state-of-the-art literature.

\item Chapter~\ref{cha:casts} we present how supercompilation can be understood from a visual perspective.

\item Chapter~\ref{cha:reflection} Parser combinators are high level description on how to parse a given language.
Because it contains a high-level of composability, supercompilation is the ideal mecanisn to exploit its essence.

\item Chapter~\ref{cha:exceptions} shows how the link between Rewrite Rules and Supercompilation.

\item Chapter~\ref{cha:unsafe} discusses about the link between Dependent types and Supercompilation.

\end{itemize}


Empirical Analysis


In the article, *In Defense of Soundiness: A Manifesto*,

https://cacm.acm.org/magazines/2015/2/182650-in-defense-of-soundiness

the authors claim that in order to understand how the limit of analysis tools impact software,
first we need to understand the what kind of code is being written in the real world.
This fact opens the door for empirical studies about language features and their use in
software repositories, e.g., Maven Central.


Platform for Deep Mining Analysis at big scale -- Empirical Deep Analysis
With a DSL?
It is costly in infrastucture
No research, just a tool paper

Studies of Casts in Java
Cast it at Your Own Risk: Java Casts in the Wild????
Use our casts empirical study to support more studies on subjects
Instead of using arbitrary experiments (tasks) use real world examples
Re-cast Reflection Empirical Study to the whole Maven repository
Hoogle for Java at big scale -- Not only signatures, but also deep code patterns

Improper use of catch exceptions, e.g., NullPointerException
Detect improper bug fixes


Reimplement the pattern search w/ static analysis?
Manual inspection does not scale up
Redo manual inspection
Is it possible to write an analysis to detect a single pattern?
Relate each pattern w/ alternatives in another languages
Criticize of language features/API design
Language for Serialization paper POPL 2006
The next 700 data description languages
Cast Patterns
Time Restrictions/Thesis Schedule
Find Concrete Thesis Statement


Graph (PDG) Comparison
Sink/Source
Linear Comparison
Code Search
Jungloid Mining

Code Pattern Search (particular for casts)
Coercion

https://www.juliasoft.com/
What are the cast patterns?
Abuses of cast
Is it code or data?

Use or not use of parametrized types?

Dominators/Immediate Dominators
A Simple, Fast Dominance Algorithm paper



Slices/Dominators \& Post-Dominators for Control Dependencies
Slices as a tree in JNIF
