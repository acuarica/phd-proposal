
\chapter{Introduction}

Programming language design has been always a hot topic in computer science literature.
It has been extensively studied in the past decades.
For instance, there is a trend in incorporating functional programming features into mainstream object-oriented languages, \eg{}, lambdas in \java{} 8\footnote{\url{https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html\#jls-15.27}}, \cpp{}11\footnote{\url{http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1968.pdf}} and \cs{} 3.0\footnote{\url{https://msdn.microsoft.com/en-us/library/bb308966.aspx\#csharp3.0overview_topic7}};
or parametric polymorphism in \java{} 5\footnote{\url{https://docs.oracle.com/javase/1.5.0/docs/guide/language/generics.html}}$^{,}$\footnote{\url{http://www.oracle.com/technetwork/java/javase/generics-tutorial-159168.pdf}}.

Adding new features to a language should --- \emph{in theory} --- increase programmers productivity.
But once a language feature is released, little is known about how it is actually used by the developer community.
Therefore, it is extremely difficult to assess how features in a language impact on programmers productivity.
\cite{hanenberg_faith_2010,hanenberg_why_2014} argue that human behavior, \ie{}, controlled experiments, should be applied to programming language usage and design.
With this approach, it should be possible --- in principle --- to understand to what degree a language feature impacts on programming productivity.
However, for any kind of controlled experiment to be valid, it must reflect reality.
Otherwise, any conjecture derived from a controlled experiment can be considered truthful but useless.

Understanding what developers write is not only useful in the field of controlled experiments.
For instance, \cite{livshits_defense_2015} argue that most software analysis tools exclude certain dynamic features, \eg{}, reflection, \jni{}\footnote{\url{https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/jniTOC.html}}, \eval{}, \etc{}, from their analyses.
They claim that in order to understand how the limits of analysis tools impact software,
we also need to understand what kind of code is being written in the real world.

Looking at the aforementioned examples, \cite{mazinanian_understanding_2017} and~\cite{uesbeck_empirical_2016}
studied how developers use lambdas in \java{} and \cpp{} respectively; while \cite{parnin_java_2011,parnin_adoption_2013} did the same for generics in \java{}.
This kind of studies give an insight of the adoption of lambdas;
which can drive future direction for language designers and tool builders,
while providing developers with best practices to the effective use of lambdas.


\section{Research Statement}

We believe that we (as a research community) should understand what kinds of programs are written in real codebases.
We can use this information to improve several aspects of the software development process and supporting informed decisions for the driving forces mentioned above.
This fact opens the door for empirical studies about language features, and their use in source code repositories, \eg{}, \github{}, \gitlab{} or \bitbucket{}, and package managers repositories, \eg{}, \mavencentral{}\footnote{\url{http://central.sonatype.org/}} or
\npm{}\footnote{\url{https://www.npmjs.com/}}.

Since any kind of language study must be language-specific, our plan is to focus on \java{} given its wide usage and relevance for both research and industry.
At its core, what we want to provide is the

\researchstatement{Understanding of how features in the \java{} language are used in the wild}

In this proposal, we plan to target four specific \java{} features, namely, \emph{casting}, \emph{reflection}, \emph{exception handling}, and the \emph{unsafe \api{}}.
We have divised --- for the \emph{unsafe} \api{} --- and we plan to divise language and \api{} usage patterns.
We believe that having usage patterns can help us to better categorize features and thus understanding how the feature is actually used.


\section{Proposal Outline}

Understanding what programmers write is a broad topic involving several sub-fields.
Chapter~\ref{cha:literature-review} gives a review of the literature in the state-of-the-art of the different aspects related to our goal. 

The following four chapters introduce our proposal plan for the selected features:
Chapter~\ref{cha:casts} presents our \emph{casting} study;
while Chapter~\ref{cha:reflection} does the same for reflection and
Chapter~\ref{cha:exceptions} for \emph{exception handling}.
Finally, Chapter~\ref{cha:unsafe} shows the study we already made on the unsafe \api{} in \java{}.

%Understanding the Use of Language Features in Java.
%To understand patterns.Mining language features thesis.
%Research Question: Is Java Safe?
%Methodological Contribution, to evolve your language.
%Motivate the umbrella that put together those 3 pillars.
%In our research proposal we investigate the feasibility of 
