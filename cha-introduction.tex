
\chapter{Introduction}

Programming language design has been always a hot topic in computer science literature.
It has been extensively studied in the past decades.
For instance, there is a trend in incorporating functional programming features into mainstream object-oriented languages, \eg{}, lambdas in \java{} 8\footnote{\url{https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html\#jls-15.27}}, \cpp{}11\footnote{\url{http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1968.pdf}} and \cs{} 3.0\footnote{\url{https://msdn.microsoft.com/en-us/library/bb308966.aspx\#csharp3.0overview_topic7}};
or parametric polymorphism in \java{} 5\footnote{\url{https://docs.oracle.com/javase/1.5.0/docs/guide/language/generics.html}}$^{,}$\footnote{\url{http://www.oracle.com/technetwork/java/javase/generics-tutorial-159168.pdf}}.

Adding new features to a language should --- \emph{in theory} --- increase programmers productivity.
But once a language feature is released, little is known about how it is actually used by the developer community.
Therefore, it is extremely difficult to assess how features in a language impact on programmers productivity.
\cite{hanenberg_faith_2010,hanenberg_why_2014} argue that human behavior, \ie{}, controlled experiments, should be applied to programming language usage and design.
With this approach, it should be possible to understand to what degree a language feature impacts on programming productivity.
However, for any kind of controlled experiment to be valid, it must reflect reality.
Likewise, \cite{livshits_defense_2015} claim that in order to understand how the limit of analysis tools impact software,
first we need to understand the what kind of code is being written in the real world.

Looking at the aforementioned examples, \cite{mazinanian_understanding_2017} and~\cite{uesbeck_empirical_2016}
studied how developers use lambdas in \java{} and \cpp{} respectively; while \cite{parnin_java_2011,parnin_adoption_2013} did the same for generics in \java{}.
This kind of studies give an insight of the adoption of language features that can drive future direction for the language and provide .

Therefore we argue that if we (as a research community) understand what kinds of programs are written in real codebases,
we can use this information to improve several aspect of the software development process.
This fact opens the door for empirical studies about language features and their use in
software repositories, e.g., Maven Central.


\section{What do we want to provide?}

\researchquestion{Understanding Java in the Wild?}

As its core, we believe that understanding how actually language features are
used is paramount.

researchers miss opportunities to improve the state of the art
tool builders use unrealistic assumptions
language designers fail to improve upon their designs
developers are unable to explore efficient and effective use of lambdas.

Understanding how developers make use of language features can be helpful to a broad range audience.
It can aid language designers to improve their languages;
tool builders can make real assumptions;
researchers to better improve the state of the art;
developers can benefit from are unable to explore efficient and effective.

Language designers add features to their languages based
We believe
three specific features, namely
We have divised and we plan to divise language and \api{} patterns in order to properly assess this driving forces.
To understand patterns

In this proposal, we plan to explore
Understanding the Use of Language Features in Java
Supporting informed decisions for these driving forces.
Exploring the usability and feasibility of creating new languages based on empirical studies



Evidence-based language as a long term goal

Mining language features thesis
Title: *Understanding Java in the Wild*
Research Question: Is Java Safe?
Methodological Contribution, to evolve your language
Motivate the umbrella that put together those 3 pillars


\section{Proposal Outline}

In our research proposal we investigate the feasibility of 

Supercompilation for specific domains.

Whether it is worth it

\begin{itemize}

\item Chapter~\ref{cha:literature-review} gives an overview of the state-of-the-art literature.

\item Chapter~\ref{cha:casts} we present how supercompilation can be understood from a visual perspective.

\item Chapter~\ref{cha:reflection} Parser combinators are high level description on how to parse a given language.
Because it contains a high-level of composability, supercompilation is the ideal mecanisn to exploit its essence.

\item Chapter~\ref{cha:exceptions} shows how the link between Rewrite Rules and Supercompilation.

\item Chapter~\ref{cha:unsafe} discusses about the link between Dependent types and Supercompilation.

\end{itemize}
