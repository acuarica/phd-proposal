
\chapter{Literature Review} \label{cha:literature-review} 

Understanding how language features and \api{}s are being used is a broad topic.
There is plenty of research in computer science literature about empirical studies of programs;
which involves several directions directly or indirecly related.

Along the last decades, researchers always has been interested in understading what kind of programs programmers write.
The motivation behind these studies is quite broad and --- together with the evolution of computer science itself --- has shifted to the needs of researchers.

In \cref{sec:msr} we give an overview of what tools are available to extract information from a software repository.

\section{Compilers Writers}

Already \cite{knuth_empirical_1971} started to study \fortran{} programs.
By knowing what kind of programs arise in practice, a compiler optimizer can focus in those cases, and therefore can be more effective.
Alternatively, to measure the advantages between compilation and interpretation in \basic{}, ~\cite{hammond_basic_1977} has studied a representative dataset of programs.
Adding to Knuth's work, \cite{shen_empirical_1990} made an empirical study for parallelizing compilers.
Similar works have been done for \cobol{}~\cite{salvadori_static_1975,chevance_static_1978}, \pascal{}~\cite{cook_contextual_1982}, and \apl{}~\cite{saal_properties_1975,saal_empirical_1977} programs.

But there is more than empirical studies at the source code level.
A machine instruction set is effectively another kind of language.
Therefore, its design of a can be affected by how compilers generate machine code.
Several studies targetted the \jvm{}~\cite{collberg_empirical_2007,odonoghue_bigram_2002,antonioli_analysis_1998}, and \lilith{}~\cite{cook_empirical_1989}

\section{Benchmarking}

Benchmarks are crucial to properly evaluate and measure product developement.
This is key for both research and industry.
One popular benchmark suite for \java{} is DaCapo~\cite{blackburn_dacapo_2006}.
This suite has been already cited in more than thousand publications, showing how important is to have reliable benchmark suites.

For any benchmark to be useful and reliable, it must faithfully represent real world code.
Therefore, we argue how important it is to make empirical studies about what programmers write.

\section{Empirical Studies on Casting}

The closest work to our casting study is by~\cite{winther_guarded_2011}.
Study of type casts in several project.
Quite similar to what we want to do.
Focus on Guarded Type casts.


\section{Impact of using Static Type systems}

Several authors~\cite{stuchlik_static_2011,mayer_empirical_2012,harlin_impact_2017} measure whether using a static-type system improves programmers productivity.
They compare how a static and a dynamic type system impact on productivity.
The common setting for these studies is to have a set of programming problems.
Then, let a group of developers solve them in both a static and dynamic languages.

For these kind of studies to reflect reality, the problems to be solved need to
be representative of the real-world code.
Having artificial problems may lead to invalid conclusions.

The work by \cite{wu_how_2017,wu_learning_2017} goes towards this direction.
They have examined programs written by students to understand real debugging conditions.
Their focus is on ill-typed programs written in \haskell{}.
Unfortunately, these dataset does not correspond to real-world code.
Our focus is to analyze code by experienced programmers.

Therefore, it is important to study how casts are used in real-world code.
Having a deep understanding of actual usage of casts can led to
Informed decisions when designing these kind of experiments.

\section{Large-scale Codebase Empirical Studies}

In the same direction to our plan, \cite{callau_how_2013} perform a study of the dynamic features of \smalltalk{}.
Analogously, \cite{richards_analysis_2010,richards_eval_2011} made a similar study, but in this case targeting \javascript{}'s dynamic behavior and in particular the \eval{} function.
\cite{reboucas_empirical_2016} made an empirical study on the \swift{} programming language.
Also for \javascript{}, \cite{madsen_string_2014} analyzed how fields are accessed via strings, while~\cite{jang_empirical_2010} analyzed privay violations.

Going one step forward, \cite{ray_large-scale_2017}

These results are useful to make informed decisions about which features to consider when designing language extensions or tool support.

%https://cacm.acm.org/magazines/2017/10/221326-a-large-scale-study-of-programming-languages-and-code-quality-in-github/fulltext



Contracts in the Wild: A Study of Java Programs
Investigate 25 fix contract patterns.
Section 2.3: Come up with new Contract Patterns.
\cite{dietrich_contracts_2017,dietrich_contracts_2017-1}

\cite{landman_challenges_2017}
Challenges for Static Analysis of Java Reflection -- Literature Review and Empirical Study
They also have done a study on Casts.
But only for a small curated sets of projects.
They analyze the relevance of static analysis tools w.r.t reflection.
We want to study Reflection in the Wild.
Empirical Studies on subjects need to be correlated with real world use cases, e.g. Maven Repository.



Spencer: Interactive Heap Analysis for the Masses
\cite{brandauer_spencer:_2017}


\subsection*{Collections and Generics}

The inclusion of generics in \java{} is closely related to collections.
Empirical Study of Usage and Performance of Java Collections
Mining GitHub corpus to study the use of collections, and how these usages can be improved.
\cite{costa_empirical_2017}

Java Generics Adoption: How New Features are Introduced, Championed,

or Ignored~\cite{parnin_java_2011,parnin_adoption_2013}


\subsection*{Exceptions}

\cite{kery_examining_2016,asaduzzaman_how_2016} focus on exceptions.
They made empirical studies on how programmers handle exceptions in \java{} code.
The work done by~\cite{nakshatri_analysis_2016} categorized them in patterns.
Whether~\cite{coelho_unveiling_2015} used a more dynamic approach by analysing stack traces and code issues in \github{}.

The exceptions mechanism is orthogonal to the features we target in this proposal.
For instance, we have detected a \smu{} pattern to \throw{} undeclared exceptions.
Similarly, closely related to \emph{casting}, \cce{} is thrown when a cast is invalid.
Therefore, we believe that these kind of studies can be complementary for our research. They can help us to understand how programmers handle exceptions in these scenarios.


\section{Code Patterns Discovery} \label{sec:pattern-discovery}

\cite{posnett_thex:_2010} have extended \asm{}~\cite{bruneton_asm:_2002,kuleshov_using_2007} to implement symbolic execution and recognize call sites.
However, this is only a meta-pattern detector, and not a pattern discovery.
\cite{hu_dynamic_2008} used both dynamic and static analysis to discover design patterns, while \cite{arcelli_design_2008} used only dynamic.

For our study on \smu{}, we needed to discover usage patterns.
Given its a singleton class, we have collected call sites,
and proceed with a semi-automatic analysis.
On the other hand, our study related to casts involved a much more complex analysis.
Therefore we have decided to implement it with manual inspection.

\section{Tools for Mining Software Repositories} \label{sec:msr}

When talking about mining software repositories, we refer to extracting any kind of information from large-scale codebase repositories.
Usually doing so requires several engineering but challenging tasks.
The most common being downloading, storing, parsing, analyzing and properly extracting different kinds of artifacts.
In this scenario, there are several tools that allows a researcher or developer to query information about software repositories.

\cite{dyer_boa:_2013,dyer_declarative_2013} built \boa{}, both a domain-specific language and a online platform\footnote{\url{http://boa.cs.iastate.edu/}}.
It is used to query software repositories on two popular hosting services, \github{}\footnote{\url{https://github.com/}} and \sourceforge{}\footnote{\url{https://sourceforge.net/}}.
The same authors of \boa{} made a study on how new features in \java{} were adopted by developers~\cite{dyer_mining_2014}.
This study is based \sourceforge{} data.
The current problem with \sourceforge{} is that is outdated.
For our study on \smu{}, we first tried using \boa{} with \sourceforge{}.
We found out that only few projects were using \smu{}.
In contrast, our final study using \maven{} found that an order of magnitude more were using \smu{}.

\cite{gousios_ghtorent_2013}
provides an offline mirror of \github{} that allows researchers to query any kind of that data.
Later on, \cite{gousios_lean_2014} published the dataset construction process of \github{}.

Another dimension to consider when analyzing large codebases, is how relevant the repositories are.
\cite{lopes_dejavu:_2017} made a study to measure code duplicity in \github{}.
They found out that much of the code there is actually duplicated.
This raises a flag when consider which projects analyze when doing mining software repositories.

Similar to \boa{}, \lgtm{}\footnote{\url{https://lgtm.com/}} is a platform to query software projects properties.
It works by querying repositories from \github{}.
But it does not work at a large-scale, \ie{}, \lgtm{} allows the user to query just a few projects.
Unlike \boa{}, \lgtm{} is based on \ql{}, an object-oriented domain-specific language to query recursive data structures~\cite{avgustinov_ql:_2016}.

On top of \boa{}, \cite{tiwari_candoia:_2017} built \candoia{}\footnote{\url{http://candoia.github.io/}}, ``A Platform for Building and Sharing Mining Software Repositories Tools as Apps''.
Although it is not a mining software repository \perse{}, it eases the creation of mining applications.

\cite{latoza_developers_2010} developers ask reachability questions.
\cite{dietrich_broken_2014} broken promises.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
